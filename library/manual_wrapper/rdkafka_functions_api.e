note

	description: "This file has been generated by WrapC. Do not edit. Changes will be lost!"

	generator: "Eiffel Wrapper Generator"
-- functions wrapper
class RDKAFKA_FUNCTIONS_API


feature -- Access

	rd_kafka_version: INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_version ();
			]"
		end

	rd_kafka_version_str: POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_version_str ();
			]"
		end

	rd_kafka_get_debug_contexts: POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_get_debug_contexts ();
			]"
		end

	rd_kafka_get_err_descs (errdescs: RD_KAFKA_ERR_DESC_STRUCT_API; cntp: POINTER)
		do
			c_rd_kafka_get_err_descs (errdescs.item, cntp)
		ensure
			instance_free: class
		end

	rd_kafka_err2str (err: INTEGER): POINTER
		do
			Result := c_rd_kafka_err2str (err)
		ensure
			instance_free: class
		end

	rd_kafka_err2name (err: INTEGER): POINTER
		do
			Result := c_rd_kafka_err2name (err)
		ensure
			instance_free: class
		end

	rd_kafka_last_error: INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_last_error ();
			]"
		end

	rd_kafka_errno2err (errnox: INTEGER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_errno2err ((int)$errnox);
			]"
		end

	rd_kafka_errno: INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_errno ();
			]"
		end

	rd_kafka_fatal_error (rk: RD_KAFKA_S_STRUCT_API; errstr: STRING_8; errstr_size: NATURAL): INTEGER
		local
			errstr_c_string: C_STRING
		do
			create errstr_c_string.make (errstr)
			Result := c_rd_kafka_fatal_error (rk.item, errstr_c_string.item, errstr_size)
		ensure
			instance_free: class
		end

	rd_kafka_test_fatal_error (rk: RD_KAFKA_S_STRUCT_API; err: INTEGER; reason: STRING_8): INTEGER
		local
			reason_c_string: C_STRING
		do
			create reason_c_string.make (reason)
			Result := c_rd_kafka_test_fatal_error (rk.item, err, reason_c_string.item)
		ensure
			instance_free: class
		end

	rd_kafka_error_code (error: RD_KAFKA_ERROR_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_error_code (error.item)
		ensure
			instance_free: class
		end

	rd_kafka_error_name (error: RD_KAFKA_ERROR_S_STRUCT_API): POINTER
		do
			Result := c_rd_kafka_error_name (error.item)
		ensure
			instance_free: class
		end

	rd_kafka_error_string (error: RD_KAFKA_ERROR_S_STRUCT_API): POINTER
		do
			Result := c_rd_kafka_error_string (error.item)
		ensure
			instance_free: class
		end

	rd_kafka_error_is_fatal (error: RD_KAFKA_ERROR_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_error_is_fatal (error.item)
		ensure
			instance_free: class
		end

	rd_kafka_error_is_retriable (error: RD_KAFKA_ERROR_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_error_is_retriable (error.item)
		ensure
			instance_free: class
		end

	rd_kafka_error_txn_requires_abort (error: RD_KAFKA_ERROR_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_error_txn_requires_abort (error.item)
		ensure
			instance_free: class
		end

	rd_kafka_error_destroy (error: RD_KAFKA_ERROR_S_STRUCT_API)
		do
			c_rd_kafka_error_destroy (error.item)
		ensure
			instance_free: class
		end

	rd_kafka_error_new (code: INTEGER; fmt: STRING_8): detachable RD_KAFKA_ERROR_S_STRUCT_API
		local
			fmt_c_string: C_STRING
		do
			create fmt_c_string.make (fmt)
			if attached c_rd_kafka_error_new (code, fmt_c_string.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_topic_partition_destroy (rktpar: RD_KAFKA_TOPIC_PARTITION_S_STRUCT_API)
		do
			c_rd_kafka_topic_partition_destroy (rktpar.item)
		ensure
			instance_free: class
		end

	rd_kafka_topic_partition_list_new (size: INTEGER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_topic_partition_list_new ((int)$size);
			]"
		end

	rd_kafka_topic_partition_list_destroy (rkparlist: RD_KAFKA_TOPIC_PARTITION_LIST_S_STRUCT_API)
		do
			c_rd_kafka_topic_partition_list_destroy (rkparlist.item)
		ensure
			instance_free: class
		end

	rd_kafka_topic_partition_list_add (rktparlist: RD_KAFKA_TOPIC_PARTITION_LIST_S_STRUCT_API; topic: STRING_8; partition: INTEGER): detachable RD_KAFKA_TOPIC_PARTITION_S_STRUCT_API
		local
			topic_c_string: C_STRING
		do
			create topic_c_string.make (topic)
			if attached c_rd_kafka_topic_partition_list_add (rktparlist.item, topic_c_string.item, partition) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_topic_partition_list_add_range (rktparlist: RD_KAFKA_TOPIC_PARTITION_LIST_S_STRUCT_API; topic: STRING_8; start: INTEGER; stop: INTEGER)
		local
			topic_c_string: C_STRING
		do
			create topic_c_string.make (topic)
			c_rd_kafka_topic_partition_list_add_range (rktparlist.item, topic_c_string.item, start, stop)
		ensure
			instance_free: class
		end

	rd_kafka_topic_partition_list_del (rktparlist: RD_KAFKA_TOPIC_PARTITION_LIST_S_STRUCT_API; topic: STRING_8; partition: INTEGER): INTEGER
		local
			topic_c_string: C_STRING
		do
			create topic_c_string.make (topic)
			Result := c_rd_kafka_topic_partition_list_del (rktparlist.item, topic_c_string.item, partition)
		ensure
			instance_free: class
		end

	rd_kafka_topic_partition_list_del_by_idx (rktparlist: RD_KAFKA_TOPIC_PARTITION_LIST_S_STRUCT_API; idx: INTEGER): INTEGER
		do
			Result := c_rd_kafka_topic_partition_list_del_by_idx (rktparlist.item, idx)
		ensure
			instance_free: class
		end

	rd_kafka_topic_partition_list_copy (src: RD_KAFKA_TOPIC_PARTITION_LIST_S_STRUCT_API): detachable RD_KAFKA_TOPIC_PARTITION_LIST_S_STRUCT_API
		do
			if attached c_rd_kafka_topic_partition_list_copy (src.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_topic_partition_list_set_offset (rktparlist: RD_KAFKA_TOPIC_PARTITION_LIST_S_STRUCT_API; topic: STRING_8; partition: INTEGER; offset: INTEGER_64): INTEGER
		local
			topic_c_string: C_STRING
		do
			create topic_c_string.make (topic)
			Result := c_rd_kafka_topic_partition_list_set_offset (rktparlist.item, topic_c_string.item, partition, offset)
		ensure
			instance_free: class
		end

	rd_kafka_topic_partition_list_find (rktparlist: RD_KAFKA_TOPIC_PARTITION_LIST_S_STRUCT_API; topic: STRING_8; partition: INTEGER): detachable RD_KAFKA_TOPIC_PARTITION_S_STRUCT_API
		local
			topic_c_string: C_STRING
		do
			create topic_c_string.make (topic)
			if attached c_rd_kafka_topic_partition_list_find (rktparlist.item, topic_c_string.item, partition) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_topic_partition_list_sort (rktparlist: RD_KAFKA_TOPIC_PARTITION_LIST_S_STRUCT_API; cmp: POINTER; cmp_opaque: POINTER)
		do
			c_rd_kafka_topic_partition_list_sort (rktparlist.item, cmp, cmp_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_headers_new (initial_count: NATURAL): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_headers_new ((size_t)$initial_count);
			]"
		end

	rd_kafka_headers_destroy (hdrs: RD_KAFKA_HEADERS_S_STRUCT_API)
		do
			c_rd_kafka_headers_destroy (hdrs.item)
		ensure
			instance_free: class
		end

	rd_kafka_headers_copy (src: RD_KAFKA_HEADERS_S_STRUCT_API): detachable RD_KAFKA_HEADERS_S_STRUCT_API
		do
			if attached c_rd_kafka_headers_copy (src.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_header_add (hdrs: RD_KAFKA_HEADERS_S_STRUCT_API; name: STRING_8; name_size: INTEGER; value: POINTER; value_size: INTEGER): INTEGER
		local
			name_c_string: C_STRING
		do
			create name_c_string.make (name)
			Result := c_rd_kafka_header_add (hdrs.item, name_c_string.item, name_size, value, value_size)
		ensure
			instance_free: class
		end

	rd_kafka_header_remove (hdrs: RD_KAFKA_HEADERS_S_STRUCT_API; name: STRING_8): INTEGER
		local
			name_c_string: C_STRING
		do
			create name_c_string.make (name)
			Result := c_rd_kafka_header_remove (hdrs.item, name_c_string.item)
		ensure
			instance_free: class
		end

	rd_kafka_header_get_last (hdrs: RD_KAFKA_HEADERS_S_STRUCT_API; name: STRING_8; valuep: POINTER; sizep: POINTER): INTEGER
		local
			name_c_string: C_STRING
		do
			create name_c_string.make (name)
			Result := c_rd_kafka_header_get_last (hdrs.item, name_c_string.item, valuep, sizep)
		ensure
			instance_free: class
		end

	rd_kafka_header_get (hdrs: RD_KAFKA_HEADERS_S_STRUCT_API; idx: NATURAL; name: STRING_8; valuep: POINTER; sizep: POINTER): INTEGER
		local
			name_c_string: C_STRING
		do
			create name_c_string.make (name)
			Result := c_rd_kafka_header_get (hdrs.item, idx, name_c_string.item, valuep, sizep)
		ensure
			instance_free: class
		end

	rd_kafka_header_get_all (hdrs: RD_KAFKA_HEADERS_S_STRUCT_API; idx: NATURAL; namep: POINTER; valuep: POINTER; sizep: POINTER): INTEGER
		do
			Result := c_rd_kafka_header_get_all (hdrs.item, idx, namep, valuep, sizep)
		ensure
			instance_free: class
		end

	rd_kafka_message_destroy (rkmessage: RD_KAFKA_MESSAGE_S_STRUCT_API)
		do
			c_rd_kafka_message_destroy (rkmessage.item)
		ensure
			instance_free: class
		end

	rd_kafka_message_errstr (rkmessage: RD_KAFKA_MESSAGE_S_STRUCT_API): POINTER
		do
			Result := c_rd_kafka_message_errstr (rkmessage.item)
		ensure
			instance_free: class
		end

	rd_kafka_message_timestamp (rkmessage: RD_KAFKA_MESSAGE_S_STRUCT_API; tstype: POINTER): INTEGER_64
		do
			Result := c_rd_kafka_message_timestamp (rkmessage.item, tstype)
		ensure
			instance_free: class
		end

	rd_kafka_message_latency (rkmessage: RD_KAFKA_MESSAGE_S_STRUCT_API): INTEGER_64
		do
			Result := c_rd_kafka_message_latency (rkmessage.item)
		ensure
			instance_free: class
		end

	rd_kafka_message_broker_id (rkmessage: RD_KAFKA_MESSAGE_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_message_broker_id (rkmessage.item)
		ensure
			instance_free: class
		end

	rd_kafka_message_headers (rkmessage: RD_KAFKA_MESSAGE_S_STRUCT_API; hdrsp: RD_KAFKA_HEADERS_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_message_headers (rkmessage.item, hdrsp.item)
		ensure
			instance_free: class
		end

	rd_kafka_message_detach_headers (rkmessage: RD_KAFKA_MESSAGE_S_STRUCT_API; hdrsp: RD_KAFKA_HEADERS_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_message_detach_headers (rkmessage.item, hdrsp.item)
		ensure
			instance_free: class
		end

	rd_kafka_message_set_headers (rkmessage: RD_KAFKA_MESSAGE_S_STRUCT_API; hdrs: RD_KAFKA_HEADERS_S_STRUCT_API)
		do
			c_rd_kafka_message_set_headers (rkmessage.item, hdrs.item)
		ensure
			instance_free: class
		end

	rd_kafka_header_cnt (hdrs: RD_KAFKA_HEADERS_S_STRUCT_API): NATURAL
		do
			Result := c_rd_kafka_header_cnt (hdrs.item)
		ensure
			instance_free: class
		end

	rd_kafka_message_status (rkmessage: RD_KAFKA_MESSAGE_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_message_status (rkmessage.item)
		ensure
			instance_free: class
		end

	rd_kafka_conf_new: detachable RD_KAFKA_CONF_S_STRUCT_API
		do
			if attached c_rd_kafka_conf_new as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_conf_destroy (conf: RD_KAFKA_CONF_S_STRUCT_API)
		do
			c_rd_kafka_conf_destroy (conf.item)
		ensure
			instance_free: class
		end

	rd_kafka_conf_dup (conf: RD_KAFKA_CONF_S_STRUCT_API): detachable RD_KAFKA_CONF_S_STRUCT_API
		do
			if attached c_rd_kafka_conf_dup (conf.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_conf_dup_filter (conf: RD_KAFKA_CONF_S_STRUCT_API; filter_cnt: NATURAL; filter: POINTER): detachable RD_KAFKA_CONF_S_STRUCT_API
		do
			if attached c_rd_kafka_conf_dup_filter (conf.item, filter_cnt, filter) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_conf (rk: RD_KAFKA_S_STRUCT_API): detachable RD_KAFKA_CONF_S_STRUCT_API
		do
			if attached c_rd_kafka_conf (rk.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_conf_set (conf: RD_KAFKA_CONF_S_STRUCT_API; name: STRING_8; value: STRING_8; errstr: STRING_8; errstr_size: NATURAL): INTEGER
		local
			name_c_string: C_STRING
			value_c_string: C_STRING
			errstr_c_string: C_STRING
		do
			create name_c_string.make (name)
			create value_c_string.make (value)
			create errstr_c_string.make (errstr)
			Result := c_rd_kafka_conf_set (conf.item, name_c_string.item, value_c_string.item, errstr_c_string.item, errstr_size)
		ensure
			instance_free: class
		end

	rd_kafka_conf_set_events (conf: RD_KAFKA_CONF_S_STRUCT_API; events: INTEGER)
		do
			c_rd_kafka_conf_set_events (conf.item, events)
		ensure
			instance_free: class
		end

	rd_kafka_conf_set_background_event_cb (conf: RD_KAFKA_CONF_S_STRUCT_API; event_cb: POINTER)
		do
			c_rd_kafka_conf_set_background_event_cb (conf.item, event_cb)
		ensure
			instance_free: class
		end

	rd_kafka_conf_set_dr_cb (conf: RD_KAFKA_CONF_S_STRUCT_API; dr_cb: POINTER)
		do
			c_rd_kafka_conf_set_dr_cb (conf.item, dr_cb)
		ensure
			instance_free: class
		end

	rd_kafka_conf_set_dr_msg_cb (conf: RD_KAFKA_CONF_S_STRUCT_API; dr_msg_cb: POINTER)
		do
			c_rd_kafka_conf_set_dr_msg_cb (conf.item, dr_msg_cb)
		ensure
			instance_free: class
		end

	rd_kafka_conf_set_consume_cb (conf: RD_KAFKA_CONF_S_STRUCT_API; consume_cb: POINTER)
		do
			c_rd_kafka_conf_set_consume_cb (conf.item, consume_cb)
		ensure
			instance_free: class
		end

	rd_kafka_conf_set_rebalance_cb (conf: RD_KAFKA_CONF_S_STRUCT_API; rebalance_cb: POINTER)
		do
			c_rd_kafka_conf_set_rebalance_cb (conf.item, rebalance_cb)
		ensure
			instance_free: class
		end

	rd_kafka_conf_set_offset_commit_cb (conf: RD_KAFKA_CONF_S_STRUCT_API; offset_commit_cb: POINTER)
		do
			c_rd_kafka_conf_set_offset_commit_cb (conf.item, offset_commit_cb)
		ensure
			instance_free: class
		end

	rd_kafka_conf_set_error_cb (conf: RD_KAFKA_CONF_S_STRUCT_API; error_cb: POINTER)
		do
			c_rd_kafka_conf_set_error_cb (conf.item, error_cb)
		ensure
			instance_free: class
		end

	rd_kafka_conf_set_throttle_cb (conf: RD_KAFKA_CONF_S_STRUCT_API; throttle_cb: POINTER)
		do
			c_rd_kafka_conf_set_throttle_cb (conf.item, throttle_cb)
		ensure
			instance_free: class
		end

	rd_kafka_conf_set_log_cb (conf: RD_KAFKA_CONF_S_STRUCT_API; log_cb: POINTER)
		do
			c_rd_kafka_conf_set_log_cb (conf.item, log_cb)
		ensure
			instance_free: class
		end

	rd_kafka_conf_set_stats_cb (conf: RD_KAFKA_CONF_S_STRUCT_API; stats_cb: POINTER)
		do
			c_rd_kafka_conf_set_stats_cb (conf.item, stats_cb)
		ensure
			instance_free: class
		end

	rd_kafka_conf_set_oauthbearer_token_refresh_cb (conf: RD_KAFKA_CONF_S_STRUCT_API; oauthbearer_token_refresh_cb: POINTER)
		do
			c_rd_kafka_conf_set_oauthbearer_token_refresh_cb (conf.item, oauthbearer_token_refresh_cb)
		ensure
			instance_free: class
		end

	rd_kafka_conf_set_socket_cb (conf: RD_KAFKA_CONF_S_STRUCT_API; socket_cb: POINTER)
		do
			c_rd_kafka_conf_set_socket_cb (conf.item, socket_cb)
		ensure
			instance_free: class
		end

	rd_kafka_conf_set_connect_cb (conf: RD_KAFKA_CONF_S_STRUCT_API; connect_cb: POINTER)
		do
			c_rd_kafka_conf_set_connect_cb (conf.item, connect_cb)
		ensure
			instance_free: class
		end

	rd_kafka_conf_set_closesocket_cb (conf: RD_KAFKA_CONF_S_STRUCT_API; closesocket_cb: POINTER)
		do
			c_rd_kafka_conf_set_closesocket_cb (conf.item, closesocket_cb)
		ensure
			instance_free: class
		end

	rd_kafka_conf_set_ssl_cert_verify_cb (conf: RD_KAFKA_CONF_S_STRUCT_API; ssl_cert_verify_cb: POINTER): INTEGER
		do
			Result := c_rd_kafka_conf_set_ssl_cert_verify_cb (conf.item, ssl_cert_verify_cb)
		ensure
			instance_free: class
		end

	rd_kafka_conf_set_ssl_cert (conf: RD_KAFKA_CONF_S_STRUCT_API; cert_type: INTEGER; cert_enc: INTEGER; buffer: POINTER; size: NATURAL; errstr: STRING_8; errstr_size: NATURAL): INTEGER
		local
			errstr_c_string: C_STRING
		do
			create errstr_c_string.make (errstr)
			Result := c_rd_kafka_conf_set_ssl_cert (conf.item, cert_type, cert_enc, buffer, size, errstr_c_string.item, errstr_size)
		ensure
			instance_free: class
		end

	rd_kafka_conf_set_opaque (conf: RD_KAFKA_CONF_S_STRUCT_API; opaque: POINTER)
		do
			c_rd_kafka_conf_set_opaque (conf.item, opaque)
		ensure
			instance_free: class
		end

	rd_kafka_opaque (rk: RD_KAFKA_S_STRUCT_API): POINTER
		do
			Result := c_rd_kafka_opaque (rk.item)
		ensure
			instance_free: class
		end

	rd_kafka_conf_set_default_topic_conf (conf: RD_KAFKA_CONF_S_STRUCT_API; tconf: RD_KAFKA_TOPIC_CONF_S_STRUCT_API)
		do
			c_rd_kafka_conf_set_default_topic_conf (conf.item, tconf.item)
		ensure
			instance_free: class
		end

	rd_kafka_conf_get (conf: RD_KAFKA_CONF_S_STRUCT_API; name: STRING_8; dest: STRING_8; dest_size: POINTER): INTEGER
		local
			name_c_string: C_STRING
			dest_c_string: C_STRING
		do
			create name_c_string.make (name)
			create dest_c_string.make (dest)
			Result := c_rd_kafka_conf_get (conf.item, name_c_string.item, dest_c_string.item, dest_size)
		ensure
			instance_free: class
		end

	rd_kafka_topic_conf_get (conf: RD_KAFKA_TOPIC_CONF_S_STRUCT_API; name: STRING_8; dest: STRING_8; dest_size: POINTER): INTEGER
		local
			name_c_string: C_STRING
			dest_c_string: C_STRING
		do
			create name_c_string.make (name)
			create dest_c_string.make (dest)
			Result := c_rd_kafka_topic_conf_get (conf.item, name_c_string.item, dest_c_string.item, dest_size)
		ensure
			instance_free: class
		end

	rd_kafka_conf_dump (conf: RD_KAFKA_CONF_S_STRUCT_API; cntp: POINTER): POINTER
		do
			Result := c_rd_kafka_conf_dump (conf.item, cntp)
		ensure
			instance_free: class
		end

	rd_kafka_topic_conf_dump (conf: RD_KAFKA_TOPIC_CONF_S_STRUCT_API; cntp: POINTER): POINTER
		do
			Result := c_rd_kafka_topic_conf_dump (conf.item, cntp)
		ensure
			instance_free: class
		end

	rd_kafka_conf_dump_free (arr: POINTER; cnt: NATURAL)
		do
			c_rd_kafka_conf_dump_free (arr, cnt)
		ensure
			instance_free: class
		end

	rd_kafka_conf_properties_show (fp: POINTER)
		do
			c_rd_kafka_conf_properties_show (fp)
		ensure
			instance_free: class
		end

	rd_kafka_topic_conf_new: detachable RD_KAFKA_TOPIC_CONF_S_STRUCT_API
		do
			if attached c_rd_kafka_topic_conf_new as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_topic_conf_dup (conf: RD_KAFKA_TOPIC_CONF_S_STRUCT_API): detachable RD_KAFKA_TOPIC_CONF_S_STRUCT_API
		do
			if attached c_rd_kafka_topic_conf_dup (conf.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_default_topic_conf_dup (rk: RD_KAFKA_S_STRUCT_API): detachable RD_KAFKA_TOPIC_CONF_S_STRUCT_API
		do
			if attached c_rd_kafka_default_topic_conf_dup (rk.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_topic_conf_destroy (topic_conf: RD_KAFKA_TOPIC_CONF_S_STRUCT_API)
		do
			c_rd_kafka_topic_conf_destroy (topic_conf.item)
		ensure
			instance_free: class
		end

	rd_kafka_topic_conf_set (conf: RD_KAFKA_TOPIC_CONF_S_STRUCT_API; name: STRING_8; value: STRING_8; errstr: STRING_8; errstr_size: NATURAL): INTEGER
		local
			name_c_string: C_STRING
			value_c_string: C_STRING
			errstr_c_string: C_STRING
		do
			create name_c_string.make (name)
			create value_c_string.make (value)
			create errstr_c_string.make (errstr)
			Result := c_rd_kafka_topic_conf_set (conf.item, name_c_string.item, value_c_string.item, errstr_c_string.item, errstr_size)
		ensure
			instance_free: class
		end

	rd_kafka_topic_conf_set_opaque (conf: RD_KAFKA_TOPIC_CONF_S_STRUCT_API; rkt_opaque: POINTER)
		do
			c_rd_kafka_topic_conf_set_opaque (conf.item, rkt_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_topic_conf_set_partitioner_cb (topic_conf: RD_KAFKA_TOPIC_CONF_S_STRUCT_API; partitioner: POINTER)
		do
			c_rd_kafka_topic_conf_set_partitioner_cb (topic_conf.item, partitioner)
		ensure
			instance_free: class
		end

	rd_kafka_topic_conf_set_msg_order_cmp (topic_conf: RD_KAFKA_TOPIC_CONF_S_STRUCT_API; msg_order_cmp: POINTER)
		do
			c_rd_kafka_topic_conf_set_msg_order_cmp (topic_conf.item, msg_order_cmp)
		ensure
			instance_free: class
		end

	rd_kafka_topic_partition_available (rkt: RD_KAFKA_TOPIC_S_STRUCT_API; partition: INTEGER): INTEGER
		do
			Result := c_rd_kafka_topic_partition_available (rkt.item, partition)
		ensure
			instance_free: class
		end

	rd_kafka_msg_partitioner_random (rkt: RD_KAFKA_TOPIC_S_STRUCT_API; key: POINTER; keylen: NATURAL; partition_cnt: INTEGER; rkt_opaque: POINTER; msg_opaque: POINTER): INTEGER
		do
			Result := c_rd_kafka_msg_partitioner_random (rkt.item, key, keylen, partition_cnt, rkt_opaque, msg_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_msg_partitioner_consistent (rkt: RD_KAFKA_TOPIC_S_STRUCT_API; key: POINTER; keylen: NATURAL; partition_cnt: INTEGER; rkt_opaque: POINTER; msg_opaque: POINTER): INTEGER
		do
			Result := c_rd_kafka_msg_partitioner_consistent (rkt.item, key, keylen, partition_cnt, rkt_opaque, msg_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_msg_partitioner_consistent_random (rkt: RD_KAFKA_TOPIC_S_STRUCT_API; key: POINTER; keylen: NATURAL; partition_cnt: INTEGER; rkt_opaque: POINTER; msg_opaque: POINTER): INTEGER
		do
			Result := c_rd_kafka_msg_partitioner_consistent_random (rkt.item, key, keylen, partition_cnt, rkt_opaque, msg_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_msg_partitioner_murmur2 (rkt: RD_KAFKA_TOPIC_S_STRUCT_API; key: POINTER; keylen: NATURAL; partition_cnt: INTEGER; rkt_opaque: POINTER; msg_opaque: POINTER): INTEGER
		do
			Result := c_rd_kafka_msg_partitioner_murmur2 (rkt.item, key, keylen, partition_cnt, rkt_opaque, msg_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_msg_partitioner_murmur2_random (rkt: RD_KAFKA_TOPIC_S_STRUCT_API; key: POINTER; keylen: NATURAL; partition_cnt: INTEGER; rkt_opaque: POINTER; msg_opaque: POINTER): INTEGER
		do
			Result := c_rd_kafka_msg_partitioner_murmur2_random (rkt.item, key, keylen, partition_cnt, rkt_opaque, msg_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_msg_partitioner_fnv1a (rkt: RD_KAFKA_TOPIC_S_STRUCT_API; key: POINTER; keylen: NATURAL; partition_cnt: INTEGER; rkt_opaque: POINTER; msg_opaque: POINTER): INTEGER
		do
			Result := c_rd_kafka_msg_partitioner_fnv1a (rkt.item, key, keylen, partition_cnt, rkt_opaque, msg_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_msg_partitioner_fnv1a_random (rkt: RD_KAFKA_TOPIC_S_STRUCT_API; key: POINTER; keylen: NATURAL; partition_cnt: INTEGER; rkt_opaque: POINTER; msg_opaque: POINTER): INTEGER
		do
			Result := c_rd_kafka_msg_partitioner_fnv1a_random (rkt.item, key, keylen, partition_cnt, rkt_opaque, msg_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_new (type: INTEGER; conf: RD_KAFKA_CONF_S_STRUCT_API; errstr: STRING_8; errstr_size: NATURAL): detachable RD_KAFKA_S_STRUCT_API
		local
			errstr_c_string: C_STRING
		do
			create errstr_c_string.make (errstr)
			if attached c_rd_kafka_new (type, conf.item, errstr_c_string.item, errstr_size) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_destroy (rk: RD_KAFKA_S_STRUCT_API)
		do
			c_rd_kafka_destroy (rk.item)
		ensure
			instance_free: class
		end

	rd_kafka_destroy_flags (rk: RD_KAFKA_S_STRUCT_API; flags: INTEGER)
		do
			c_rd_kafka_destroy_flags (rk.item, flags)
		ensure
			instance_free: class
		end

	rd_kafka_name (rk: RD_KAFKA_S_STRUCT_API): POINTER
		do
			Result := c_rd_kafka_name (rk.item)
		ensure
			instance_free: class
		end

	rd_kafka_type (rk: RD_KAFKA_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_type (rk.item)
		ensure
			instance_free: class
		end

	rd_kafka_memberid (rk: RD_KAFKA_S_STRUCT_API): POINTER
		do
			Result := c_rd_kafka_memberid (rk.item)
		ensure
			instance_free: class
		end

	rd_kafka_clusterid (rk: RD_KAFKA_S_STRUCT_API; timeout_ms: INTEGER): POINTER
		do
			Result := c_rd_kafka_clusterid (rk.item, timeout_ms)
		ensure
			instance_free: class
		end

	rd_kafka_controllerid (rk: RD_KAFKA_S_STRUCT_API; timeout_ms: INTEGER): INTEGER
		do
			Result := c_rd_kafka_controllerid (rk.item, timeout_ms)
		ensure
			instance_free: class
		end

	rd_kafka_topic_new (rk: RD_KAFKA_S_STRUCT_API; topic: STRING_8; conf: RD_KAFKA_TOPIC_CONF_S_STRUCT_API): detachable RD_KAFKA_TOPIC_S_STRUCT_API
		local
			topic_c_string: C_STRING
		do
			create topic_c_string.make (topic)
			if attached c_rd_kafka_topic_new (rk.item, topic_c_string.item, conf.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_topic_destroy (rkt: RD_KAFKA_TOPIC_S_STRUCT_API)
		do
			c_rd_kafka_topic_destroy (rkt.item)
		ensure
			instance_free: class
		end

	rd_kafka_topic_name (rkt: RD_KAFKA_TOPIC_S_STRUCT_API): POINTER
		do
			Result := c_rd_kafka_topic_name (rkt.item)
		ensure
			instance_free: class
		end

	rd_kafka_topic_opaque (rkt: RD_KAFKA_TOPIC_S_STRUCT_API): POINTER
		do
			Result := c_rd_kafka_topic_opaque (rkt.item)
		ensure
			instance_free: class
		end

	rd_kafka_poll (rk: RD_KAFKA_S_STRUCT_API; timeout_ms: INTEGER): INTEGER
		do
			Result := c_rd_kafka_poll (rk.item, timeout_ms)
		ensure
			instance_free: class
		end

	rd_kafka_yield (rk: RD_KAFKA_S_STRUCT_API)
		do
			c_rd_kafka_yield (rk.item)
		ensure
			instance_free: class
		end

	rd_kafka_pause_partitions (rk: RD_KAFKA_S_STRUCT_API; partitions: RD_KAFKA_TOPIC_PARTITION_LIST_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_pause_partitions (rk.item, partitions.item)
		ensure
			instance_free: class
		end

	rd_kafka_resume_partitions (rk: RD_KAFKA_S_STRUCT_API; partitions: RD_KAFKA_TOPIC_PARTITION_LIST_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_resume_partitions (rk.item, partitions.item)
		ensure
			instance_free: class
		end

	rd_kafka_query_watermark_offsets (rk: RD_KAFKA_S_STRUCT_API; topic: STRING_8; partition: INTEGER; low: POINTER; high: POINTER; timeout_ms: INTEGER): INTEGER
		local
			topic_c_string: C_STRING
		do
			create topic_c_string.make (topic)
			Result := c_rd_kafka_query_watermark_offsets (rk.item, topic_c_string.item, partition, low, high, timeout_ms)
		ensure
			instance_free: class
		end

	rd_kafka_get_watermark_offsets (rk: RD_KAFKA_S_STRUCT_API; topic: STRING_8; partition: INTEGER; low: POINTER; high: POINTER): INTEGER
		local
			topic_c_string: C_STRING
		do
			create topic_c_string.make (topic)
			Result := c_rd_kafka_get_watermark_offsets (rk.item, topic_c_string.item, partition, low, high)
		ensure
			instance_free: class
		end

	rd_kafka_offsets_for_times (rk: RD_KAFKA_S_STRUCT_API; offsets: RD_KAFKA_TOPIC_PARTITION_LIST_S_STRUCT_API; timeout_ms: INTEGER): INTEGER
		do
			Result := c_rd_kafka_offsets_for_times (rk.item, offsets.item, timeout_ms)
		ensure
			instance_free: class
		end

	rd_kafka_mem_free (rk: RD_KAFKA_S_STRUCT_API; ptr: POINTER)
		do
			c_rd_kafka_mem_free (rk.item, ptr)
		ensure
			instance_free: class
		end

	rd_kafka_queue_new (rk: RD_KAFKA_S_STRUCT_API): detachable RD_KAFKA_QUEUE_S_STRUCT_API
		do
			if attached c_rd_kafka_queue_new (rk.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_queue_destroy (rkqu: RD_KAFKA_QUEUE_S_STRUCT_API)
		do
			c_rd_kafka_queue_destroy (rkqu.item)
		ensure
			instance_free: class
		end

	rd_kafka_queue_get_main (rk: RD_KAFKA_S_STRUCT_API): detachable RD_KAFKA_QUEUE_S_STRUCT_API
		do
			if attached c_rd_kafka_queue_get_main (rk.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_queue_get_consumer (rk: RD_KAFKA_S_STRUCT_API): detachable RD_KAFKA_QUEUE_S_STRUCT_API
		do
			if attached c_rd_kafka_queue_get_consumer (rk.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_queue_get_partition (rk: RD_KAFKA_S_STRUCT_API; topic: STRING_8; partition: INTEGER): detachable RD_KAFKA_QUEUE_S_STRUCT_API
		local
			topic_c_string: C_STRING
		do
			create topic_c_string.make (topic)
			if attached c_rd_kafka_queue_get_partition (rk.item, topic_c_string.item, partition) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_queue_get_background (rk: RD_KAFKA_S_STRUCT_API): detachable RD_KAFKA_QUEUE_S_STRUCT_API
		do
			if attached c_rd_kafka_queue_get_background (rk.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_queue_forward (src: RD_KAFKA_QUEUE_S_STRUCT_API; dst: RD_KAFKA_QUEUE_S_STRUCT_API)
		do
			c_rd_kafka_queue_forward (src.item, dst.item)
		ensure
			instance_free: class
		end

	rd_kafka_set_log_queue (rk: RD_KAFKA_S_STRUCT_API; rkqu: RD_KAFKA_QUEUE_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_set_log_queue (rk.item, rkqu.item)
		ensure
			instance_free: class
		end

	rd_kafka_queue_length (rkqu: RD_KAFKA_QUEUE_S_STRUCT_API): NATURAL
		do
			Result := c_rd_kafka_queue_length (rkqu.item)
		ensure
			instance_free: class
		end

	rd_kafka_queue_io_event_enable (rkqu: RD_KAFKA_QUEUE_S_STRUCT_API; fd: INTEGER; payload: POINTER; size: NATURAL)
		do
			c_rd_kafka_queue_io_event_enable (rkqu.item, fd, payload, size)
		ensure
			instance_free: class
		end

	rd_kafka_queue_cb_event_enable (rkqu: RD_KAFKA_QUEUE_S_STRUCT_API; event_cb: POINTER; qev_opaque: POINTER)
		do
			c_rd_kafka_queue_cb_event_enable (rkqu.item, event_cb, qev_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_consume_start (rkt: RD_KAFKA_TOPIC_S_STRUCT_API; partition: INTEGER; offset: INTEGER_64): INTEGER
		do
			Result := c_rd_kafka_consume_start (rkt.item, partition, offset)
		ensure
			instance_free: class
		end

	rd_kafka_consume_start_queue (rkt: RD_KAFKA_TOPIC_S_STRUCT_API; partition: INTEGER; offset: INTEGER_64; rkqu: RD_KAFKA_QUEUE_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_consume_start_queue (rkt.item, partition, offset, rkqu.item)
		ensure
			instance_free: class
		end

	rd_kafka_consume_stop (rkt: RD_KAFKA_TOPIC_S_STRUCT_API; partition: INTEGER): INTEGER
		do
			Result := c_rd_kafka_consume_stop (rkt.item, partition)
		ensure
			instance_free: class
		end

	rd_kafka_seek (rkt: RD_KAFKA_TOPIC_S_STRUCT_API; partition: INTEGER; offset: INTEGER_64; timeout_ms: INTEGER): INTEGER
		do
			Result := c_rd_kafka_seek (rkt.item, partition, offset, timeout_ms)
		ensure
			instance_free: class
		end

	rd_kafka_consume (rkt: RD_KAFKA_TOPIC_S_STRUCT_API; partition: INTEGER; timeout_ms: INTEGER): detachable RD_KAFKA_MESSAGE_S_STRUCT_API
		do
			if attached c_rd_kafka_consume (rkt.item, partition, timeout_ms) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_consume_batch (rkt: RD_KAFKA_TOPIC_S_STRUCT_API; partition: INTEGER; timeout_ms: INTEGER; rkmessages: RD_KAFKA_MESSAGE_S_STRUCT_API; rkmessages_size: NATURAL): INTEGER
		do
			Result := c_rd_kafka_consume_batch (rkt.item, partition, timeout_ms, rkmessages.item, rkmessages_size)
		ensure
			instance_free: class
		end

	rd_kafka_consume_callback (rkt: RD_KAFKA_TOPIC_S_STRUCT_API; partition: INTEGER; timeout_ms: INTEGER; consume_cb: POINTER; commit_opaque: POINTER): INTEGER
		do
			Result := c_rd_kafka_consume_callback (rkt.item, partition, timeout_ms, consume_cb, commit_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_consume_queue (rkqu: RD_KAFKA_QUEUE_S_STRUCT_API; timeout_ms: INTEGER): detachable RD_KAFKA_MESSAGE_S_STRUCT_API
		do
			if attached c_rd_kafka_consume_queue (rkqu.item, timeout_ms) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_consume_batch_queue (rkqu: RD_KAFKA_QUEUE_S_STRUCT_API; timeout_ms: INTEGER; rkmessages: RD_KAFKA_MESSAGE_S_STRUCT_API; rkmessages_size: NATURAL): INTEGER
		do
			Result := c_rd_kafka_consume_batch_queue (rkqu.item, timeout_ms, rkmessages.item, rkmessages_size)
		ensure
			instance_free: class
		end

	rd_kafka_consume_callback_queue (rkqu: RD_KAFKA_QUEUE_S_STRUCT_API; timeout_ms: INTEGER; consume_cb: POINTER; commit_opaque: POINTER): INTEGER
		do
			Result := c_rd_kafka_consume_callback_queue (rkqu.item, timeout_ms, consume_cb, commit_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_offset_store (rkt: RD_KAFKA_TOPIC_S_STRUCT_API; partition: INTEGER; offset: INTEGER_64): INTEGER
		do
			Result := c_rd_kafka_offset_store (rkt.item, partition, offset)
		ensure
			instance_free: class
		end

	rd_kafka_offsets_store (rk: RD_KAFKA_S_STRUCT_API; offsets: RD_KAFKA_TOPIC_PARTITION_LIST_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_offsets_store (rk.item, offsets.item)
		ensure
			instance_free: class
		end

	rd_kafka_subscribe (rk: RD_KAFKA_S_STRUCT_API; topics: RD_KAFKA_TOPIC_PARTITION_LIST_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_subscribe (rk.item, topics.item)
		ensure
			instance_free: class
		end

	rd_kafka_unsubscribe (rk: RD_KAFKA_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_unsubscribe (rk.item)
		ensure
			instance_free: class
		end

	rd_kafka_subscription (rk: RD_KAFKA_S_STRUCT_API; topics: RD_KAFKA_TOPIC_PARTITION_LIST_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_subscription (rk.item, topics.item)
		ensure
			instance_free: class
		end

	rd_kafka_consumer_poll (rk: RD_KAFKA_S_STRUCT_API; timeout_ms: INTEGER): detachable RD_KAFKA_MESSAGE_S_STRUCT_API
		do
			if attached c_rd_kafka_consumer_poll (rk.item, timeout_ms) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_consumer_close (rk: RD_KAFKA_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_consumer_close (rk.item)
		ensure
			instance_free: class
		end

	rd_kafka_assign (rk: RD_KAFKA_S_STRUCT_API; partitions: RD_KAFKA_TOPIC_PARTITION_LIST_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_assign (rk.item, partitions.item)
		ensure
			instance_free: class
		end

	rd_kafka_assignment (rk: RD_KAFKA_S_STRUCT_API; partitions: RD_KAFKA_TOPIC_PARTITION_LIST_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_assignment (rk.item, partitions.item)
		ensure
			instance_free: class
		end

	rd_kafka_commit (rk: RD_KAFKA_S_STRUCT_API; offsets: RD_KAFKA_TOPIC_PARTITION_LIST_S_STRUCT_API; async: INTEGER): INTEGER
		do
			Result := c_rd_kafka_commit (rk.item, offsets.item, async)
		ensure
			instance_free: class
		end

	rd_kafka_commit_message (rk: RD_KAFKA_S_STRUCT_API; rkmessage: RD_KAFKA_MESSAGE_S_STRUCT_API; async: INTEGER): INTEGER
		do
			Result := c_rd_kafka_commit_message (rk.item, rkmessage.item, async)
		ensure
			instance_free: class
		end

	rd_kafka_commit_queue (rk: RD_KAFKA_S_STRUCT_API; offsets: RD_KAFKA_TOPIC_PARTITION_LIST_S_STRUCT_API; rkqu: RD_KAFKA_QUEUE_S_STRUCT_API; cb: POINTER; commit_opaque: POINTER): INTEGER
		do
			Result := c_rd_kafka_commit_queue (rk.item, offsets.item, rkqu.item, cb, commit_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_committed (rk: RD_KAFKA_S_STRUCT_API; partitions: RD_KAFKA_TOPIC_PARTITION_LIST_S_STRUCT_API; timeout_ms: INTEGER): INTEGER
		do
			Result := c_rd_kafka_committed (rk.item, partitions.item, timeout_ms)
		ensure
			instance_free: class
		end

	rd_kafka_position (rk: RD_KAFKA_S_STRUCT_API; partitions: RD_KAFKA_TOPIC_PARTITION_LIST_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_position (rk.item, partitions.item)
		ensure
			instance_free: class
		end

	rd_kafka_consumer_group_metadata (rk: RD_KAFKA_S_STRUCT_API): detachable RD_KAFKA_CONSUMER_GROUP_METADATA_S_STRUCT_API
		do
			if attached c_rd_kafka_consumer_group_metadata (rk.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_consumer_group_metadata_new (group_id: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_consumer_group_metadata_new ((char const*)$group_id);
			]"
		end

	rd_kafka_consumer_group_metadata_destroy (anonymous_1: RD_KAFKA_CONSUMER_GROUP_METADATA_S_STRUCT_API)
		do
			c_rd_kafka_consumer_group_metadata_destroy (anonymous_1.item)
		ensure
			instance_free: class
		end

	rd_kafka_consumer_group_metadata_write (cgmd: RD_KAFKA_CONSUMER_GROUP_METADATA_S_STRUCT_API; bufferp: POINTER; sizep: POINTER): detachable RD_KAFKA_ERROR_S_STRUCT_API
		do
			if attached c_rd_kafka_consumer_group_metadata_write (cgmd.item, bufferp, sizep) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_consumer_group_metadata_read (cgmdp: RD_KAFKA_CONSUMER_GROUP_METADATA_S_STRUCT_API; buffer: POINTER; size: NATURAL): detachable RD_KAFKA_ERROR_S_STRUCT_API
		do
			if attached c_rd_kafka_consumer_group_metadata_read (cgmdp.item, buffer, size) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_produce (rkt: RD_KAFKA_TOPIC_S_STRUCT_API; partition: INTEGER; msgflags: INTEGER; payload: POINTER; len: NATURAL; key: POINTER; keylen: NATURAL; msg_opaque: POINTER): INTEGER
		do
			Result := c_rd_kafka_produce (rkt.item, partition, msgflags, payload, len, key, keylen, msg_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_producev (rk: RD_KAFKA_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_producev (rk.item)
		ensure
			instance_free: class
		end

	rd_kafka_produceva (rk: RD_KAFKA_S_STRUCT_API; vus: RD_KAFKA_VU_S_STRUCT_API; cnt: NATURAL): detachable RD_KAFKA_ERROR_S_STRUCT_API
		do
			if attached c_rd_kafka_produceva (rk.item, vus.item, cnt) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_produce_batch (rkt: RD_KAFKA_TOPIC_S_STRUCT_API; partition: INTEGER; msgflags: INTEGER; rkmessages: RD_KAFKA_MESSAGE_S_STRUCT_API; message_cnt: INTEGER): INTEGER
		do
			Result := c_rd_kafka_produce_batch (rkt.item, partition, msgflags, rkmessages.item, message_cnt)
		ensure
			instance_free: class
		end

	rd_kafka_flush (rk: RD_KAFKA_S_STRUCT_API; timeout_ms: INTEGER): INTEGER
		do
			Result := c_rd_kafka_flush (rk.item, timeout_ms)
		ensure
			instance_free: class
		end

	rd_kafka_purge (rk: RD_KAFKA_S_STRUCT_API; purge_flags: INTEGER): INTEGER
		do
			Result := c_rd_kafka_purge (rk.item, purge_flags)
		ensure
			instance_free: class
		end

	rd_kafka_metadata (rk: RD_KAFKA_S_STRUCT_API; all_topics: INTEGER; only_rkt: RD_KAFKA_TOPIC_S_STRUCT_API; metadatap: RD_KAFKA_METADATA_STRUCT_API; timeout_ms: INTEGER): INTEGER
		do
			Result := c_rd_kafka_metadata (rk.item, all_topics, only_rkt.item, metadatap.item, timeout_ms)
		ensure
			instance_free: class
		end

	rd_kafka_metadata_destroy (metadata: RD_KAFKA_METADATA_STRUCT_API)
		do
			c_rd_kafka_metadata_destroy (metadata.item)
		ensure
			instance_free: class
		end

	rd_kafka_list_groups (rk: RD_KAFKA_S_STRUCT_API; group: STRING_8; grplistp: RD_KAFKA_GROUP_LIST_STRUCT_API; timeout_ms: INTEGER): INTEGER
		local
			group_c_string: C_STRING
		do
			create group_c_string.make (group)
			Result := c_rd_kafka_list_groups (rk.item, group_c_string.item, grplistp.item, timeout_ms)
		ensure
			instance_free: class
		end

	rd_kafka_group_list_destroy (grplist: RD_KAFKA_GROUP_LIST_STRUCT_API)
		do
			c_rd_kafka_group_list_destroy (grplist.item)
		ensure
			instance_free: class
		end

	rd_kafka_brokers_add (rk: RD_KAFKA_S_STRUCT_API; brokerlist: STRING_8): INTEGER
		local
			brokerlist_c_string: C_STRING
		do
			create brokerlist_c_string.make (brokerlist)
			Result := c_rd_kafka_brokers_add (rk.item, brokerlist_c_string.item)
		ensure
			instance_free: class
		end

	rd_kafka_set_logger (rk: RD_KAFKA_S_STRUCT_API; func: POINTER)
		do
			c_rd_kafka_set_logger (rk.item, func)
		ensure
			instance_free: class
		end

	rd_kafka_set_log_level (rk: RD_KAFKA_S_STRUCT_API; level: INTEGER)
		do
			c_rd_kafka_set_log_level (rk.item, level)
		ensure
			instance_free: class
		end

	rd_kafka_log_print (rk: RD_KAFKA_S_STRUCT_API; level: INTEGER; fac: STRING_8; buf: STRING_8)
		local
			fac_c_string: C_STRING
			buf_c_string: C_STRING
		do
			create fac_c_string.make (fac)
			create buf_c_string.make (buf)
			c_rd_kafka_log_print (rk.item, level, fac_c_string.item, buf_c_string.item)
		ensure
			instance_free: class
		end

	rd_kafka_log_syslog (rk: RD_KAFKA_S_STRUCT_API; level: INTEGER; fac: STRING_8; buf: STRING_8)
		local
			fac_c_string: C_STRING
			buf_c_string: C_STRING
		do
			create fac_c_string.make (fac)
			create buf_c_string.make (buf)
			c_rd_kafka_log_syslog (rk.item, level, fac_c_string.item, buf_c_string.item)
		ensure
			instance_free: class
		end

	rd_kafka_outq_len (rk: RD_KAFKA_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_outq_len (rk.item)
		ensure
			instance_free: class
		end

	rd_kafka_dump (fp: POINTER; rk: RD_KAFKA_S_STRUCT_API)
		do
			c_rd_kafka_dump (fp, rk.item)
		ensure
			instance_free: class
		end

	rd_kafka_thread_cnt: INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_thread_cnt ();
			]"
		end

	rd_kafka_wait_destroyed (timeout_ms: INTEGER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_wait_destroyed ((int)$timeout_ms);
			]"
		end

	rd_kafka_unittest: INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_unittest ();
			]"
		end

	rd_kafka_poll_set_consumer (rk: RD_KAFKA_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_poll_set_consumer (rk.item)
		ensure
			instance_free: class
		end

	rd_kafka_event_type (rkev: RD_KAFKA_OP_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_event_type (rkev.item)
		ensure
			instance_free: class
		end

	rd_kafka_event_name (rkev: RD_KAFKA_OP_S_STRUCT_API): POINTER
		do
			Result := c_rd_kafka_event_name (rkev.item)
		ensure
			instance_free: class
		end

	rd_kafka_event_destroy (rkev: RD_KAFKA_OP_S_STRUCT_API)
		do
			c_rd_kafka_event_destroy (rkev.item)
		ensure
			instance_free: class
		end

	rd_kafka_event_message_next (rkev: RD_KAFKA_OP_S_STRUCT_API): detachable RD_KAFKA_MESSAGE_S_STRUCT_API
		do
			if attached c_rd_kafka_event_message_next (rkev.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_event_message_array (rkev: RD_KAFKA_OP_S_STRUCT_API; rkmessages: RD_KAFKA_MESSAGE_S_STRUCT_API; size: NATURAL): NATURAL
		do
			Result := c_rd_kafka_event_message_array (rkev.item, rkmessages.item, size)
		ensure
			instance_free: class
		end

	rd_kafka_event_message_count (rkev: RD_KAFKA_OP_S_STRUCT_API): NATURAL
		do
			Result := c_rd_kafka_event_message_count (rkev.item)
		ensure
			instance_free: class
		end

	rd_kafka_event_config_string (rkev: RD_KAFKA_OP_S_STRUCT_API): POINTER
		do
			Result := c_rd_kafka_event_config_string (rkev.item)
		ensure
			instance_free: class
		end

	rd_kafka_event_error (rkev: RD_KAFKA_OP_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_event_error (rkev.item)
		ensure
			instance_free: class
		end

	rd_kafka_event_error_string (rkev: RD_KAFKA_OP_S_STRUCT_API): POINTER
		do
			Result := c_rd_kafka_event_error_string (rkev.item)
		ensure
			instance_free: class
		end

	rd_kafka_event_error_is_fatal (rkev: RD_KAFKA_OP_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_event_error_is_fatal (rkev.item)
		ensure
			instance_free: class
		end

	rd_kafka_event_opaque (rkev: RD_KAFKA_OP_S_STRUCT_API): POINTER
		do
			Result := c_rd_kafka_event_opaque (rkev.item)
		ensure
			instance_free: class
		end

	rd_kafka_event_log (rkev: RD_KAFKA_OP_S_STRUCT_API; fac: POINTER; str: POINTER; level: TYPED_POINTER [INTEGER]): INTEGER
		do
			Result := c_rd_kafka_event_log (rkev.item, fac, str, level)
		ensure
			instance_free: class
		end

	rd_kafka_event_debug_contexts (rkev: RD_KAFKA_OP_S_STRUCT_API; dst: STRING_8; dstsize: NATURAL): INTEGER
		local
			dst_c_string: C_STRING
		do
			create dst_c_string.make (dst)
			Result := c_rd_kafka_event_debug_contexts (rkev.item, dst_c_string.item, dstsize)
		ensure
			instance_free: class
		end

	rd_kafka_event_stats (rkev: RD_KAFKA_OP_S_STRUCT_API): POINTER
		do
			Result := c_rd_kafka_event_stats (rkev.item)
		ensure
			instance_free: class
		end

	rd_kafka_event_topic_partition_list (rkev: RD_KAFKA_OP_S_STRUCT_API): detachable RD_KAFKA_TOPIC_PARTITION_LIST_S_STRUCT_API
		do
			if attached c_rd_kafka_event_topic_partition_list (rkev.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_event_topic_partition (rkev: RD_KAFKA_OP_S_STRUCT_API): detachable RD_KAFKA_TOPIC_PARTITION_S_STRUCT_API
		do
			if attached c_rd_kafka_event_topic_partition (rkev.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_event_create_topics_result (rkev: RD_KAFKA_OP_S_STRUCT_API): detachable RD_KAFKA_OP_S_STRUCT_API
		do
			if attached c_rd_kafka_event_create_topics_result (rkev.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_event_delete_topics_result (rkev: RD_KAFKA_OP_S_STRUCT_API): detachable RD_KAFKA_OP_S_STRUCT_API
		do
			if attached c_rd_kafka_event_delete_topics_result (rkev.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_event_create_partitions_result (rkev: RD_KAFKA_OP_S_STRUCT_API): detachable RD_KAFKA_OP_S_STRUCT_API
		do
			if attached c_rd_kafka_event_create_partitions_result (rkev.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_event_alter_configs_result (rkev: RD_KAFKA_OP_S_STRUCT_API): detachable RD_KAFKA_OP_S_STRUCT_API
		do
			if attached c_rd_kafka_event_alter_configs_result (rkev.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_event_describe_configs_result (rkev: RD_KAFKA_OP_S_STRUCT_API): detachable RD_KAFKA_OP_S_STRUCT_API
		do
			if attached c_rd_kafka_event_describe_configs_result (rkev.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_queue_poll (rkqu: RD_KAFKA_QUEUE_S_STRUCT_API; timeout_ms: INTEGER): detachable RD_KAFKA_OP_S_STRUCT_API
		do
			if attached c_rd_kafka_queue_poll (rkqu.item, timeout_ms) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_queue_poll_callback (rkqu: RD_KAFKA_QUEUE_S_STRUCT_API; timeout_ms: INTEGER): INTEGER
		do
			Result := c_rd_kafka_queue_poll_callback (rkqu.item, timeout_ms)
		ensure
			instance_free: class
		end

	rd_kafka_conf_interceptor_add_on_conf_set (conf: RD_KAFKA_CONF_S_STRUCT_API; ic_name: STRING_8; on_conf_set: POINTER; ic_opaque: POINTER): INTEGER
		local
			ic_name_c_string: C_STRING
		do
			create ic_name_c_string.make (ic_name)
			Result := c_rd_kafka_conf_interceptor_add_on_conf_set (conf.item, ic_name_c_string.item, on_conf_set, ic_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_conf_interceptor_add_on_conf_dup (conf: RD_KAFKA_CONF_S_STRUCT_API; ic_name: STRING_8; on_conf_dup: POINTER; ic_opaque: POINTER): INTEGER
		local
			ic_name_c_string: C_STRING
		do
			create ic_name_c_string.make (ic_name)
			Result := c_rd_kafka_conf_interceptor_add_on_conf_dup (conf.item, ic_name_c_string.item, on_conf_dup, ic_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_conf_interceptor_add_on_conf_destroy (conf: RD_KAFKA_CONF_S_STRUCT_API; ic_name: STRING_8; on_conf_destroy: POINTER; ic_opaque: POINTER): INTEGER
		local
			ic_name_c_string: C_STRING
		do
			create ic_name_c_string.make (ic_name)
			Result := c_rd_kafka_conf_interceptor_add_on_conf_destroy (conf.item, ic_name_c_string.item, on_conf_destroy, ic_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_conf_interceptor_add_on_new (conf: RD_KAFKA_CONF_S_STRUCT_API; ic_name: STRING_8; on_new: POINTER; ic_opaque: POINTER): INTEGER
		local
			ic_name_c_string: C_STRING
		do
			create ic_name_c_string.make (ic_name)
			Result := c_rd_kafka_conf_interceptor_add_on_new (conf.item, ic_name_c_string.item, on_new, ic_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_interceptor_add_on_destroy (rk: RD_KAFKA_S_STRUCT_API; ic_name: STRING_8; on_destroy: POINTER; ic_opaque: POINTER): INTEGER
		local
			ic_name_c_string: C_STRING
		do
			create ic_name_c_string.make (ic_name)
			Result := c_rd_kafka_interceptor_add_on_destroy (rk.item, ic_name_c_string.item, on_destroy, ic_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_interceptor_add_on_send (rk: RD_KAFKA_S_STRUCT_API; ic_name: STRING_8; on_send: POINTER; ic_opaque: POINTER): INTEGER
		local
			ic_name_c_string: C_STRING
		do
			create ic_name_c_string.make (ic_name)
			Result := c_rd_kafka_interceptor_add_on_send (rk.item, ic_name_c_string.item, on_send, ic_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_interceptor_add_on_acknowledgement (rk: RD_KAFKA_S_STRUCT_API; ic_name: STRING_8; on_acknowledgement: POINTER; ic_opaque: POINTER): INTEGER
		local
			ic_name_c_string: C_STRING
		do
			create ic_name_c_string.make (ic_name)
			Result := c_rd_kafka_interceptor_add_on_acknowledgement (rk.item, ic_name_c_string.item, on_acknowledgement, ic_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_interceptor_add_on_consume (rk: RD_KAFKA_S_STRUCT_API; ic_name: STRING_8; on_consume: POINTER; ic_opaque: POINTER): INTEGER
		local
			ic_name_c_string: C_STRING
		do
			create ic_name_c_string.make (ic_name)
			Result := c_rd_kafka_interceptor_add_on_consume (rk.item, ic_name_c_string.item, on_consume, ic_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_interceptor_add_on_commit (rk: RD_KAFKA_S_STRUCT_API; ic_name: STRING_8; on_commit: POINTER; ic_opaque: POINTER): INTEGER
		local
			ic_name_c_string: C_STRING
		do
			create ic_name_c_string.make (ic_name)
			Result := c_rd_kafka_interceptor_add_on_commit (rk.item, ic_name_c_string.item, on_commit, ic_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_interceptor_add_on_request_sent (rk: RD_KAFKA_S_STRUCT_API; ic_name: STRING_8; on_request_sent: POINTER; ic_opaque: POINTER): INTEGER
		local
			ic_name_c_string: C_STRING
		do
			create ic_name_c_string.make (ic_name)
			Result := c_rd_kafka_interceptor_add_on_request_sent (rk.item, ic_name_c_string.item, on_request_sent, ic_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_interceptor_add_on_thread_start (rk: RD_KAFKA_S_STRUCT_API; ic_name: STRING_8; on_thread_start: POINTER; ic_opaque: POINTER): INTEGER
		local
			ic_name_c_string: C_STRING
		do
			create ic_name_c_string.make (ic_name)
			Result := c_rd_kafka_interceptor_add_on_thread_start (rk.item, ic_name_c_string.item, on_thread_start, ic_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_interceptor_add_on_thread_exit (rk: RD_KAFKA_S_STRUCT_API; ic_name: STRING_8; on_thread_exit: POINTER; ic_opaque: POINTER): INTEGER
		local
			ic_name_c_string: C_STRING
		do
			create ic_name_c_string.make (ic_name)
			Result := c_rd_kafka_interceptor_add_on_thread_exit (rk.item, ic_name_c_string.item, on_thread_exit, ic_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_topic_result_error (topicres: RD_KAFKA_TOPIC_RESULT_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_topic_result_error (topicres.item)
		ensure
			instance_free: class
		end

	rd_kafka_topic_result_error_string (topicres: RD_KAFKA_TOPIC_RESULT_S_STRUCT_API): POINTER
		do
			Result := c_rd_kafka_topic_result_error_string (topicres.item)
		ensure
			instance_free: class
		end

	rd_kafka_topic_result_name (topicres: RD_KAFKA_TOPIC_RESULT_S_STRUCT_API): POINTER
		do
			Result := c_rd_kafka_topic_result_name (topicres.item)
		ensure
			instance_free: class
		end

	rd_kafka_admin_options_new (rk: RD_KAFKA_S_STRUCT_API; for_api: INTEGER): detachable RD_KAFKA_ADMIN_OPTIONS_S_STRUCT_API
		do
			if attached c_rd_kafka_admin_options_new (rk.item, for_api) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_admin_options_destroy (options: RD_KAFKA_ADMIN_OPTIONS_S_STRUCT_API)
		do
			c_rd_kafka_admin_options_destroy (options.item)
		ensure
			instance_free: class
		end

	rd_kafka_admin_options_set_request_timeout (options: RD_KAFKA_ADMIN_OPTIONS_S_STRUCT_API; timeout_ms: INTEGER; errstr: STRING_8; errstr_size: NATURAL): INTEGER
		local
			errstr_c_string: C_STRING
		do
			create errstr_c_string.make (errstr)
			Result := c_rd_kafka_admin_options_set_request_timeout (options.item, timeout_ms, errstr_c_string.item, errstr_size)
		ensure
			instance_free: class
		end

	rd_kafka_admin_options_set_operation_timeout (options: RD_KAFKA_ADMIN_OPTIONS_S_STRUCT_API; timeout_ms: INTEGER; errstr: STRING_8; errstr_size: NATURAL): INTEGER
		local
			errstr_c_string: C_STRING
		do
			create errstr_c_string.make (errstr)
			Result := c_rd_kafka_admin_options_set_operation_timeout (options.item, timeout_ms, errstr_c_string.item, errstr_size)
		ensure
			instance_free: class
		end

	rd_kafka_admin_options_set_validate_only (options: RD_KAFKA_ADMIN_OPTIONS_S_STRUCT_API; true_or_false: INTEGER; errstr: STRING_8; errstr_size: NATURAL): INTEGER
		local
			errstr_c_string: C_STRING
		do
			create errstr_c_string.make (errstr)
			Result := c_rd_kafka_admin_options_set_validate_only (options.item, true_or_false, errstr_c_string.item, errstr_size)
		ensure
			instance_free: class
		end

	rd_kafka_admin_options_set_broker (options: RD_KAFKA_ADMIN_OPTIONS_S_STRUCT_API; broker_id: INTEGER; errstr: STRING_8; errstr_size: NATURAL): INTEGER
		local
			errstr_c_string: C_STRING
		do
			create errstr_c_string.make (errstr)
			Result := c_rd_kafka_admin_options_set_broker (options.item, broker_id, errstr_c_string.item, errstr_size)
		ensure
			instance_free: class
		end

	rd_kafka_admin_options_set_opaque (options: RD_KAFKA_ADMIN_OPTIONS_S_STRUCT_API; ev_opaque: POINTER)
		do
			c_rd_kafka_admin_options_set_opaque (options.item, ev_opaque)
		ensure
			instance_free: class
		end

	rd_kafka_new_topic_new (topic: POINTER; num_partitions: INTEGER; replication_factor: INTEGER; errstr: POINTER; errstr_size: NATURAL): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_NewTopic_new ((char const*)$topic, (int)$num_partitions, (int)$replication_factor, (char*)$errstr, (size_t)$errstr_size);
			]"
		end

	rd_kafka_new_topic_destroy (new_topic: RD_KAFKA_NEW_TOPIC_S_STRUCT_API)
		do
			c_rd_kafka_new_topic_destroy (new_topic.item)
		ensure
			instance_free: class
		end

	rd_kafka_new_topic_destroy_array (new_topics: RD_KAFKA_NEW_TOPIC_S_STRUCT_API; new_topic_cnt: NATURAL)
		do
			c_rd_kafka_new_topic_destroy_array (new_topics.item, new_topic_cnt)
		ensure
			instance_free: class
		end

	rd_kafka_new_topic_set_replica_assignment (new_topic: RD_KAFKA_NEW_TOPIC_S_STRUCT_API; partition: INTEGER; broker_ids: POINTER; broker_id_cnt: NATURAL; errstr: STRING_8; errstr_size: NATURAL): INTEGER
		local
			errstr_c_string: C_STRING
		do
			create errstr_c_string.make (errstr)
			Result := c_rd_kafka_new_topic_set_replica_assignment (new_topic.item, partition, broker_ids, broker_id_cnt, errstr_c_string.item, errstr_size)
		ensure
			instance_free: class
		end

	rd_kafka_new_topic_set_config (new_topic: RD_KAFKA_NEW_TOPIC_S_STRUCT_API; name: STRING_8; value: STRING_8): INTEGER
		local
			name_c_string: C_STRING
			value_c_string: C_STRING
		do
			create name_c_string.make (name)
			create value_c_string.make (value)
			Result := c_rd_kafka_new_topic_set_config (new_topic.item, name_c_string.item, value_c_string.item)
		ensure
			instance_free: class
		end

	rd_kafka_create_topics (rk: RD_KAFKA_S_STRUCT_API; new_topics: RD_KAFKA_NEW_TOPIC_S_STRUCT_API; new_topic_cnt: NATURAL; options: RD_KAFKA_ADMIN_OPTIONS_S_STRUCT_API; rkqu: RD_KAFKA_QUEUE_S_STRUCT_API)
		do
			c_rd_kafka_create_topics (rk.item, new_topics.item, new_topic_cnt, options.item, rkqu.item)
		ensure
			instance_free: class
		end

	rd_kafka_create_topics_result_topics (a_result: RD_KAFKA_OP_S_STRUCT_API; cntp: POINTER): detachable RD_KAFKA_TOPIC_RESULT_S_STRUCT_API
		do
			if attached c_rd_kafka_create_topics_result_topics (a_result.item, cntp) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_delete_topic_new (topic: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_DeleteTopic_new ((char const*)$topic);
			]"
		end

	rd_kafka_delete_topic_destroy (del_topic: RD_KAFKA_DELETE_TOPIC_S_STRUCT_API)
		do
			c_rd_kafka_delete_topic_destroy (del_topic.item)
		ensure
			instance_free: class
		end

	rd_kafka_delete_topic_destroy_array (del_topics: RD_KAFKA_DELETE_TOPIC_S_STRUCT_API; del_topic_cnt: NATURAL)
		do
			c_rd_kafka_delete_topic_destroy_array (del_topics.item, del_topic_cnt)
		ensure
			instance_free: class
		end

	rd_kafka_delete_topics (rk: RD_KAFKA_S_STRUCT_API; del_topics: RD_KAFKA_DELETE_TOPIC_S_STRUCT_API; del_topic_cnt: NATURAL; options: RD_KAFKA_ADMIN_OPTIONS_S_STRUCT_API; rkqu: RD_KAFKA_QUEUE_S_STRUCT_API)
		do
			c_rd_kafka_delete_topics (rk.item, del_topics.item, del_topic_cnt, options.item, rkqu.item)
		ensure
			instance_free: class
		end

	rd_kafka_delete_topics_result_topics (a_result: RD_KAFKA_OP_S_STRUCT_API; cntp: POINTER): detachable RD_KAFKA_TOPIC_RESULT_S_STRUCT_API
		do
			if attached c_rd_kafka_delete_topics_result_topics (a_result.item, cntp) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_new_partitions_new (topic: POINTER; new_total_cnt: NATURAL; errstr: POINTER; errstr_size: NATURAL): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_NewPartitions_new ((char const*)$topic, (size_t)$new_total_cnt, (char*)$errstr, (size_t)$errstr_size);
			]"
		end

	rd_kafka_new_partitions_destroy (new_parts: RD_KAFKA_NEW_PARTITIONS_S_STRUCT_API)
		do
			c_rd_kafka_new_partitions_destroy (new_parts.item)
		ensure
			instance_free: class
		end

	rd_kafka_new_partitions_destroy_array (new_parts: RD_KAFKA_NEW_PARTITIONS_S_STRUCT_API; new_parts_cnt: NATURAL)
		do
			c_rd_kafka_new_partitions_destroy_array (new_parts.item, new_parts_cnt)
		ensure
			instance_free: class
		end

	rd_kafka_new_partitions_set_replica_assignment (new_parts: RD_KAFKA_NEW_PARTITIONS_S_STRUCT_API; new_partition_idx: INTEGER; broker_ids: POINTER; broker_id_cnt: NATURAL; errstr: STRING_8; errstr_size: NATURAL): INTEGER
		local
			errstr_c_string: C_STRING
		do
			create errstr_c_string.make (errstr)
			Result := c_rd_kafka_new_partitions_set_replica_assignment (new_parts.item, new_partition_idx, broker_ids, broker_id_cnt, errstr_c_string.item, errstr_size)
		ensure
			instance_free: class
		end

	rd_kafka_create_partitions (rk: RD_KAFKA_S_STRUCT_API; new_parts: RD_KAFKA_NEW_PARTITIONS_S_STRUCT_API; new_parts_cnt: NATURAL; options: RD_KAFKA_ADMIN_OPTIONS_S_STRUCT_API; rkqu: RD_KAFKA_QUEUE_S_STRUCT_API)
		do
			c_rd_kafka_create_partitions (rk.item, new_parts.item, new_parts_cnt, options.item, rkqu.item)
		ensure
			instance_free: class
		end

	rd_kafka_create_partitions_result_topics (a_result: RD_KAFKA_OP_S_STRUCT_API; cntp: POINTER): detachable RD_KAFKA_TOPIC_RESULT_S_STRUCT_API
		do
			if attached c_rd_kafka_create_partitions_result_topics (a_result.item, cntp) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_config_source_name (confsource: INTEGER): POINTER
		do
			Result := c_rd_kafka_config_source_name (confsource)
		ensure
			instance_free: class
		end

	rd_kafka_config_entry_name (entry: RD_KAFKA_CONFIG_ENTRY_S_STRUCT_API): POINTER
		do
			Result := c_rd_kafka_config_entry_name (entry.item)
		ensure
			instance_free: class
		end

	rd_kafka_config_entry_value (entry: RD_KAFKA_CONFIG_ENTRY_S_STRUCT_API): POINTER
		do
			Result := c_rd_kafka_config_entry_value (entry.item)
		ensure
			instance_free: class
		end

	rd_kafka_config_entry_source (entry: RD_KAFKA_CONFIG_ENTRY_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_config_entry_source (entry.item)
		ensure
			instance_free: class
		end

	rd_kafka_config_entry_is_read_only (entry: RD_KAFKA_CONFIG_ENTRY_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_config_entry_is_read_only (entry.item)
		ensure
			instance_free: class
		end

	rd_kafka_config_entry_is_default (entry: RD_KAFKA_CONFIG_ENTRY_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_config_entry_is_default (entry.item)
		ensure
			instance_free: class
		end

	rd_kafka_config_entry_is_sensitive (entry: RD_KAFKA_CONFIG_ENTRY_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_config_entry_is_sensitive (entry.item)
		ensure
			instance_free: class
		end

	rd_kafka_config_entry_is_synonym (entry: RD_KAFKA_CONFIG_ENTRY_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_config_entry_is_synonym (entry.item)
		ensure
			instance_free: class
		end

	rd_kafka_config_entry_synonyms (entry: RD_KAFKA_CONFIG_ENTRY_S_STRUCT_API; cntp: POINTER): detachable RD_KAFKA_CONFIG_ENTRY_S_STRUCT_API
		do
			if attached c_rd_kafka_config_entry_synonyms (entry.item, cntp) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_resource_type_name (restype: INTEGER): POINTER
		do
			Result := c_rd_kafka_resource_type_name (restype)
		ensure
			instance_free: class
		end

	rd_kafka_config_resource_new (restype: INTEGER; resname: STRING_8): detachable RD_KAFKA_CONFIG_RESOURCE_S_STRUCT_API
		local
			resname_c_string: C_STRING
		do
			create resname_c_string.make (resname)
			if attached c_rd_kafka_config_resource_new (restype, resname_c_string.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_config_resource_destroy (config: RD_KAFKA_CONFIG_RESOURCE_S_STRUCT_API)
		do
			c_rd_kafka_config_resource_destroy (config.item)
		ensure
			instance_free: class
		end

	rd_kafka_config_resource_destroy_array (config: RD_KAFKA_CONFIG_RESOURCE_S_STRUCT_API; config_cnt: NATURAL)
		do
			c_rd_kafka_config_resource_destroy_array (config.item, config_cnt)
		ensure
			instance_free: class
		end

	rd_kafka_config_resource_set_config (config: RD_KAFKA_CONFIG_RESOURCE_S_STRUCT_API; name: STRING_8; value: STRING_8): INTEGER
		local
			name_c_string: C_STRING
			value_c_string: C_STRING
		do
			create name_c_string.make (name)
			create value_c_string.make (value)
			Result := c_rd_kafka_config_resource_set_config (config.item, name_c_string.item, value_c_string.item)
		ensure
			instance_free: class
		end

	rd_kafka_config_resource_configs (config: RD_KAFKA_CONFIG_RESOURCE_S_STRUCT_API; cntp: POINTER): detachable RD_KAFKA_CONFIG_ENTRY_S_STRUCT_API
		do
			if attached c_rd_kafka_config_resource_configs (config.item, cntp) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_config_resource_type (config: RD_KAFKA_CONFIG_RESOURCE_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_config_resource_type (config.item)
		ensure
			instance_free: class
		end

	rd_kafka_config_resource_name (config: RD_KAFKA_CONFIG_RESOURCE_S_STRUCT_API): POINTER
		do
			Result := c_rd_kafka_config_resource_name (config.item)
		ensure
			instance_free: class
		end

	rd_kafka_config_resource_error (config: RD_KAFKA_CONFIG_RESOURCE_S_STRUCT_API): INTEGER
		do
			Result := c_rd_kafka_config_resource_error (config.item)
		ensure
			instance_free: class
		end

	rd_kafka_config_resource_error_string (config: RD_KAFKA_CONFIG_RESOURCE_S_STRUCT_API): POINTER
		do
			Result := c_rd_kafka_config_resource_error_string (config.item)
		ensure
			instance_free: class
		end

	rd_kafka_alter_configs (rk: RD_KAFKA_S_STRUCT_API; configs: RD_KAFKA_CONFIG_RESOURCE_S_STRUCT_API; config_cnt: NATURAL; options: RD_KAFKA_ADMIN_OPTIONS_S_STRUCT_API; rkqu: RD_KAFKA_QUEUE_S_STRUCT_API)
		do
			c_rd_kafka_alter_configs (rk.item, configs.item, config_cnt, options.item, rkqu.item)
		ensure
			instance_free: class
		end

	rd_kafka_alter_configs_result_resources (a_result: RD_KAFKA_OP_S_STRUCT_API; cntp: POINTER): detachable RD_KAFKA_CONFIG_RESOURCE_S_STRUCT_API
		do
			if attached c_rd_kafka_alter_configs_result_resources (a_result.item, cntp) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_describe_configs (rk: RD_KAFKA_S_STRUCT_API; configs: RD_KAFKA_CONFIG_RESOURCE_S_STRUCT_API; config_cnt: NATURAL; options: RD_KAFKA_ADMIN_OPTIONS_S_STRUCT_API; rkqu: RD_KAFKA_QUEUE_S_STRUCT_API)
		do
			c_rd_kafka_describe_configs (rk.item, configs.item, config_cnt, options.item, rkqu.item)
		ensure
			instance_free: class
		end

	rd_kafka_describe_configs_result_resources (a_result: RD_KAFKA_OP_S_STRUCT_API; cntp: POINTER): detachable RD_KAFKA_CONFIG_RESOURCE_S_STRUCT_API
		do
			if attached c_rd_kafka_describe_configs_result_resources (a_result.item, cntp) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_oauthbearer_set_token (rk: RD_KAFKA_S_STRUCT_API; token_value: STRING_8; md_lifetime_ms: INTEGER_64; md_principal_name: STRING_8; extensions: POINTER; extension_size: NATURAL; errstr: STRING_8; errstr_size: NATURAL): INTEGER
		local
			token_value_c_string: C_STRING
			md_principal_name_c_string: C_STRING
			errstr_c_string: C_STRING
		do
			create token_value_c_string.make (token_value)
			create md_principal_name_c_string.make (md_principal_name)
			create errstr_c_string.make (errstr)
			Result := c_rd_kafka_oauthbearer_set_token (rk.item, token_value_c_string.item, md_lifetime_ms, md_principal_name_c_string.item, extensions, extension_size, errstr_c_string.item, errstr_size)
		ensure
			instance_free: class
		end

	rd_kafka_oauthbearer_set_token_failure (rk: RD_KAFKA_S_STRUCT_API; errstr: STRING_8): INTEGER
		local
			errstr_c_string: C_STRING
		do
			create errstr_c_string.make (errstr)
			Result := c_rd_kafka_oauthbearer_set_token_failure (rk.item, errstr_c_string.item)
		ensure
			instance_free: class
		end

	rd_kafka_init_transactions (rk: RD_KAFKA_S_STRUCT_API; timeout_ms: INTEGER): detachable RD_KAFKA_ERROR_S_STRUCT_API
		do
			if attached c_rd_kafka_init_transactions (rk.item, timeout_ms) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_begin_transaction (rk: RD_KAFKA_S_STRUCT_API): detachable RD_KAFKA_ERROR_S_STRUCT_API
		do
			if attached c_rd_kafka_begin_transaction (rk.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_send_offsets_to_transaction (rk: RD_KAFKA_S_STRUCT_API; offsets: RD_KAFKA_TOPIC_PARTITION_LIST_S_STRUCT_API; cgmetadata: RD_KAFKA_CONSUMER_GROUP_METADATA_S_STRUCT_API; timeout_ms: INTEGER): detachable RD_KAFKA_ERROR_S_STRUCT_API
		do
			if attached c_rd_kafka_send_offsets_to_transaction (rk.item, offsets.item, cgmetadata.item, timeout_ms) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_commit_transaction (rk: RD_KAFKA_S_STRUCT_API; timeout_ms: INTEGER): detachable RD_KAFKA_ERROR_S_STRUCT_API
		do
			if attached c_rd_kafka_commit_transaction (rk.item, timeout_ms) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	rd_kafka_abort_transaction (rk: RD_KAFKA_S_STRUCT_API; timeout_ms: INTEGER): detachable RD_KAFKA_ERROR_S_STRUCT_API
		do
			if attached c_rd_kafka_abort_transaction (rk.item, timeout_ms) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

feature -- Externals

	c_rd_kafka_get_err_descs (errdescs: POINTER; cntp: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_get_err_descs ((struct rd_kafka_err_desc const**)$errdescs, (size_t*)$cntp);
			]"
		end

	c_rd_kafka_err2str (err: INTEGER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_err2str ((rd_kafka_resp_err_t)$err);
			]"
		end

	c_rd_kafka_err2name (err: INTEGER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_err2name ((rd_kafka_resp_err_t)$err);
			]"
		end

	c_rd_kafka_fatal_error (rk: POINTER; errstr: POINTER; errstr_size: NATURAL): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_fatal_error ((rd_kafka_t*)$rk, (char*)$errstr, (size_t)$errstr_size);
			]"
		end

	c_rd_kafka_test_fatal_error (rk: POINTER; err: INTEGER; reason: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_test_fatal_error ((rd_kafka_t*)$rk, (rd_kafka_resp_err_t)$err, (char const*)$reason);
			]"
		end

	c_rd_kafka_error_code (error: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_error_code ((rd_kafka_error_t const*)$error);
			]"
		end

	c_rd_kafka_error_name (error: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_error_name ((rd_kafka_error_t const*)$error);
			]"
		end

	c_rd_kafka_error_string (error: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_error_string ((rd_kafka_error_t const*)$error);
			]"
		end

	c_rd_kafka_error_is_fatal (error: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_error_is_fatal ((rd_kafka_error_t const*)$error);
			]"
		end

	c_rd_kafka_error_is_retriable (error: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_error_is_retriable ((rd_kafka_error_t const*)$error);
			]"
		end

	c_rd_kafka_error_txn_requires_abort (error: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_error_txn_requires_abort ((rd_kafka_error_t const*)$error);
			]"
		end

	c_rd_kafka_error_destroy (error: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_error_destroy ((rd_kafka_error_t*)$error);
			]"
		end

	c_rd_kafka_error_new (code: INTEGER; fmt: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_error_new ((rd_kafka_resp_err_t)$code, (char const*)$fmt);
			]"
		end

	c_rd_kafka_topic_partition_destroy (rktpar: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_topic_partition_destroy ((rd_kafka_topic_partition_t*)$rktpar);
			]"
		end

	c_rd_kafka_topic_partition_list_destroy (rkparlist: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_topic_partition_list_destroy ((rd_kafka_topic_partition_list_t*)$rkparlist);
			]"
		end

	c_rd_kafka_topic_partition_list_add (rktparlist: POINTER; topic: POINTER; partition: INTEGER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_topic_partition_list_add ((rd_kafka_topic_partition_list_t*)$rktparlist, (char const*)$topic, (int32_t)$partition);
			]"
		end

	c_rd_kafka_topic_partition_list_add_range (rktparlist: POINTER; topic: POINTER; start: INTEGER; stop: INTEGER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_topic_partition_list_add_range ((rd_kafka_topic_partition_list_t*)$rktparlist, (char const*)$topic, (int32_t)$start, (int32_t)$stop);
			]"
		end

	c_rd_kafka_topic_partition_list_del (rktparlist: POINTER; topic: POINTER; partition: INTEGER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_topic_partition_list_del ((rd_kafka_topic_partition_list_t*)$rktparlist, (char const*)$topic, (int32_t)$partition);
			]"
		end

	c_rd_kafka_topic_partition_list_del_by_idx (rktparlist: POINTER; idx: INTEGER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_topic_partition_list_del_by_idx ((rd_kafka_topic_partition_list_t*)$rktparlist, (int)$idx);
			]"
		end

	c_rd_kafka_topic_partition_list_copy (src: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_topic_partition_list_copy ((rd_kafka_topic_partition_list_t const*)$src);
			]"
		end

	c_rd_kafka_topic_partition_list_set_offset (rktparlist: POINTER; topic: POINTER; partition: INTEGER; offset: INTEGER_64): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_topic_partition_list_set_offset ((rd_kafka_topic_partition_list_t*)$rktparlist, (char const*)$topic, (int32_t)$partition, (int64_t)$offset);
			]"
		end

	c_rd_kafka_topic_partition_list_find (rktparlist: POINTER; topic: POINTER; partition: INTEGER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_topic_partition_list_find ((rd_kafka_topic_partition_list_t*)$rktparlist, (char const*)$topic, (int32_t)$partition);
			]"
		end

	c_rd_kafka_topic_partition_list_sort (rktparlist: POINTER; cmp: POINTER; cmp_opaque: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_topic_partition_list_sort ((rd_kafka_topic_partition_list_t*)$rktparlist, (int (*) (void const *a, void const *b, void *cmp_opaque))$cmp, (void*)$cmp_opaque);
			]"
		end

	c_rd_kafka_headers_destroy (hdrs: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_headers_destroy ((rd_kafka_headers_t*)$hdrs);
			]"
		end

	c_rd_kafka_headers_copy (src: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_headers_copy ((rd_kafka_headers_t const*)$src);
			]"
		end

	c_rd_kafka_header_add (hdrs: POINTER; name: POINTER; name_size: INTEGER; value: POINTER; value_size: INTEGER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_header_add ((rd_kafka_headers_t*)$hdrs, (char const*)$name, (ssize_t)$name_size, (void const*)$value, (ssize_t)$value_size);
			]"
		end

	c_rd_kafka_header_remove (hdrs: POINTER; name: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_header_remove ((rd_kafka_headers_t*)$hdrs, (char const*)$name);
			]"
		end

	c_rd_kafka_header_get_last (hdrs: POINTER; name: POINTER; valuep: POINTER; sizep: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_header_get_last ((rd_kafka_headers_t const*)$hdrs, (char const*)$name, (void const**)$valuep, (size_t*)$sizep);
			]"
		end

	c_rd_kafka_header_get (hdrs: POINTER; idx: NATURAL; name: POINTER; valuep: POINTER; sizep: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_header_get ((rd_kafka_headers_t const*)$hdrs, (size_t)$idx, (char const*)$name, (void const**)$valuep, (size_t*)$sizep);
			]"
		end

	c_rd_kafka_header_get_all (hdrs: POINTER; idx: NATURAL; namep: POINTER; valuep: POINTER; sizep: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_header_get_all ((rd_kafka_headers_t const*)$hdrs, (size_t)$idx, (char const**)$namep, (void const**)$valuep, (size_t*)$sizep);
			]"
		end

	c_rd_kafka_message_destroy (rkmessage: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_message_destroy ((rd_kafka_message_t*)$rkmessage);
			]"
		end

	c_rd_kafka_message_errstr (rkmessage: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_message_errstr ((rd_kafka_message_t const*)$rkmessage);
			]"
		end

	c_rd_kafka_message_timestamp (rkmessage: POINTER; tstype: POINTER): INTEGER_64
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_message_timestamp ((rd_kafka_message_t const*)$rkmessage, (rd_kafka_timestamp_type_t*)$tstype);
			]"
		end

	c_rd_kafka_message_latency (rkmessage: POINTER): INTEGER_64
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_message_latency ((rd_kafka_message_t const*)$rkmessage);
			]"
		end

	c_rd_kafka_message_broker_id (rkmessage: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_message_broker_id ((rd_kafka_message_t const*)$rkmessage);
			]"
		end

	c_rd_kafka_message_headers (rkmessage: POINTER; hdrsp: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_message_headers ((rd_kafka_message_t const*)$rkmessage, (rd_kafka_headers_t**)$hdrsp);
			]"
		end

	c_rd_kafka_message_detach_headers (rkmessage: POINTER; hdrsp: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_message_detach_headers ((rd_kafka_message_t*)$rkmessage, (rd_kafka_headers_t**)$hdrsp);
			]"
		end

	c_rd_kafka_message_set_headers (rkmessage: POINTER; hdrs: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_message_set_headers ((rd_kafka_message_t*)$rkmessage, (rd_kafka_headers_t*)$hdrs);
			]"
		end

	c_rd_kafka_header_cnt (hdrs: POINTER): NATURAL
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_header_cnt ((rd_kafka_headers_t const*)$hdrs);
			]"
		end

	c_rd_kafka_message_status (rkmessage: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_message_status ((rd_kafka_message_t const*)$rkmessage);
			]"
		end

	c_rd_kafka_conf_new: POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_conf_new ();
			]"
		end

	c_rd_kafka_conf_destroy (conf: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_conf_destroy ((rd_kafka_conf_t*)$conf);
			]"
		end

	c_rd_kafka_conf_dup (conf: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_conf_dup ((rd_kafka_conf_t const*)$conf);
			]"
		end

	c_rd_kafka_conf_dup_filter (conf: POINTER; filter_cnt: NATURAL; filter: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_conf_dup_filter ((rd_kafka_conf_t const*)$conf, (size_t)$filter_cnt, (char const**)$filter);
			]"
		end

	c_rd_kafka_conf (rk: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_conf ((rd_kafka_t*)$rk);
			]"
		end

	c_rd_kafka_conf_set (conf: POINTER; name: POINTER; value: POINTER; errstr: POINTER; errstr_size: NATURAL): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_conf_set ((rd_kafka_conf_t*)$conf, (char const*)$name, (char const*)$value, (char*)$errstr, (size_t)$errstr_size);
			]"
		end

	c_rd_kafka_conf_set_events (conf: POINTER; events: INTEGER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_conf_set_events ((rd_kafka_conf_t*)$conf, (int)$events);
			]"
		end

	c_rd_kafka_conf_set_background_event_cb (conf: POINTER; event_cb: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_conf_set_background_event_cb ((rd_kafka_conf_t*)$conf, (void (*) (rd_kafka_t *rk, rd_kafka_event_t *rkev, void *opaque))$event_cb);
			]"
		end

	c_rd_kafka_conf_set_dr_cb (conf: POINTER; dr_cb: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_conf_set_dr_cb ((rd_kafka_conf_t*)$conf, (void (*) (rd_kafka_t *rk, void *payload, size_t len, rd_kafka_resp_err_t err, void *opaque, void *msg_opaque))$dr_cb);
			]"
		end

	c_rd_kafka_conf_set_dr_msg_cb (conf: POINTER; dr_msg_cb: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_conf_set_dr_msg_cb ((rd_kafka_conf_t*)$conf, (void (*) (rd_kafka_t *rk, rd_kafka_message_t const *rkmessage, void *opaque))$dr_msg_cb);
			]"
		end

	c_rd_kafka_conf_set_consume_cb (conf: POINTER; consume_cb: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_conf_set_consume_cb ((rd_kafka_conf_t*)$conf, (void (*) (rd_kafka_message_t *rkmessage, void *opaque))$consume_cb);
			]"
		end

	c_rd_kafka_conf_set_rebalance_cb (conf: POINTER; rebalance_cb: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_conf_set_rebalance_cb ((rd_kafka_conf_t*)$conf, (void (*) (rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *partitions, void *opaque))$rebalance_cb);
			]"
		end

	c_rd_kafka_conf_set_offset_commit_cb (conf: POINTER; offset_commit_cb: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_conf_set_offset_commit_cb ((rd_kafka_conf_t*)$conf, (void (*) (rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *opaque))$offset_commit_cb);
			]"
		end

	c_rd_kafka_conf_set_error_cb (conf: POINTER; error_cb: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_conf_set_error_cb ((rd_kafka_conf_t*)$conf, (void (*) (rd_kafka_t *rk, int err, char const *reason, void *opaque))$error_cb);
			]"
		end

	c_rd_kafka_conf_set_throttle_cb (conf: POINTER; throttle_cb: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_conf_set_throttle_cb ((rd_kafka_conf_t*)$conf, (void (*) (rd_kafka_t *rk, char const *broker_name, int32_t broker_id, int throttle_time_ms, void *opaque))$throttle_cb);
			]"
		end

	c_rd_kafka_conf_set_log_cb (conf: POINTER; log_cb: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_conf_set_log_cb ((rd_kafka_conf_t*)$conf, (void (*) (rd_kafka_t const *rk, int level, char const *fac, char const *buf))$log_cb);
			]"
		end

	c_rd_kafka_conf_set_stats_cb (conf: POINTER; stats_cb: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_conf_set_stats_cb ((rd_kafka_conf_t*)$conf, (int (*) (rd_kafka_t *rk, char *json, size_t json_len, void *opaque))$stats_cb);
			]"
		end

	c_rd_kafka_conf_set_oauthbearer_token_refresh_cb (conf: POINTER; oauthbearer_token_refresh_cb: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_conf_set_oauthbearer_token_refresh_cb ((rd_kafka_conf_t*)$conf, (void (*) (rd_kafka_t *rk, char const *oauthbearer_config, void *opaque))$oauthbearer_token_refresh_cb);
			]"
		end

	c_rd_kafka_conf_set_socket_cb (conf: POINTER; socket_cb: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_conf_set_socket_cb ((rd_kafka_conf_t*)$conf, (int (*) (int domain, int type, int protocol, void *opaque))$socket_cb);
			]"
		end

	c_rd_kafka_conf_set_connect_cb (conf: POINTER; connect_cb: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_conf_set_connect_cb ((rd_kafka_conf_t*)$conf, (int (*) (int sockfd, struct sockaddr const *addr, int addrlen, char const *id, void *opaque))$connect_cb);
			]"
		end

	c_rd_kafka_conf_set_closesocket_cb (conf: POINTER; closesocket_cb: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_conf_set_closesocket_cb ((rd_kafka_conf_t*)$conf, (int (*) (int sockfd, void *opaque))$closesocket_cb);
			]"
		end

	c_rd_kafka_conf_set_ssl_cert_verify_cb (conf: POINTER; ssl_cert_verify_cb: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_conf_set_ssl_cert_verify_cb ((rd_kafka_conf_t*)$conf, (int (*) (rd_kafka_t *rk, char const *broker_name, int32_t broker_id, int *x509_error, int depth, char const *buf, size_t size, char *errstr, size_t errstr_size, void *opaque))$ssl_cert_verify_cb);
			]"
		end

	c_rd_kafka_conf_set_ssl_cert (conf: POINTER; cert_type: INTEGER; cert_enc: INTEGER; buffer: POINTER; size: NATURAL; errstr: POINTER; errstr_size: NATURAL): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_conf_set_ssl_cert ((rd_kafka_conf_t*)$conf, (rd_kafka_cert_type_t)$cert_type, (rd_kafka_cert_enc_t)$cert_enc, (void const*)$buffer, (size_t)$size, (char*)$errstr, (size_t)$errstr_size);
			]"
		end

	c_rd_kafka_conf_set_opaque (conf: POINTER; opaque: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_conf_set_opaque ((rd_kafka_conf_t*)$conf, (void*)$opaque);
			]"
		end

	c_rd_kafka_opaque (rk: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_opaque ((rd_kafka_t const*)$rk);
			]"
		end

	c_rd_kafka_conf_set_default_topic_conf (conf: POINTER; tconf: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_conf_set_default_topic_conf ((rd_kafka_conf_t*)$conf, (rd_kafka_topic_conf_t*)$tconf);
			]"
		end

	c_rd_kafka_conf_get (conf: POINTER; name: POINTER; dest: POINTER; dest_size: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_conf_get ((rd_kafka_conf_t const*)$conf, (char const*)$name, (char*)$dest, (size_t*)$dest_size);
			]"
		end

	c_rd_kafka_topic_conf_get (conf: POINTER; name: POINTER; dest: POINTER; dest_size: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_topic_conf_get ((rd_kafka_topic_conf_t const*)$conf, (char const*)$name, (char*)$dest, (size_t*)$dest_size);
			]"
		end

	c_rd_kafka_conf_dump (conf: POINTER; cntp: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_conf_dump ((rd_kafka_conf_t*)$conf, (size_t*)$cntp);
			]"
		end

	c_rd_kafka_topic_conf_dump (conf: POINTER; cntp: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_topic_conf_dump ((rd_kafka_topic_conf_t*)$conf, (size_t*)$cntp);
			]"
		end

	c_rd_kafka_conf_dump_free (arr: POINTER; cnt: NATURAL)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_conf_dump_free ((char const**)$arr, (size_t)$cnt);
			]"
		end

	c_rd_kafka_conf_properties_show (fp: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_conf_properties_show ((FILE*)$fp);
			]"
		end

	c_rd_kafka_topic_conf_new: POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_topic_conf_new ();
			]"
		end

	c_rd_kafka_topic_conf_dup (conf: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_topic_conf_dup ((rd_kafka_topic_conf_t const*)$conf);
			]"
		end

	c_rd_kafka_default_topic_conf_dup (rk: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_default_topic_conf_dup ((rd_kafka_t*)$rk);
			]"
		end

	c_rd_kafka_topic_conf_destroy (topic_conf: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_topic_conf_destroy ((rd_kafka_topic_conf_t*)$topic_conf);
			]"
		end

	c_rd_kafka_topic_conf_set (conf: POINTER; name: POINTER; value: POINTER; errstr: POINTER; errstr_size: NATURAL): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_topic_conf_set ((rd_kafka_topic_conf_t*)$conf, (char const*)$name, (char const*)$value, (char*)$errstr, (size_t)$errstr_size);
			]"
		end

	c_rd_kafka_topic_conf_set_opaque (conf: POINTER; rkt_opaque: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_topic_conf_set_opaque ((rd_kafka_topic_conf_t*)$conf, (void*)$rkt_opaque);
			]"
		end

	c_rd_kafka_topic_conf_set_partitioner_cb (topic_conf: POINTER; partitioner: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_topic_conf_set_partitioner_cb ((rd_kafka_topic_conf_t*)$topic_conf, (int32_t (*) (rd_kafka_topic_t const *rkt, void const *keydata, size_t keylen, int32_t partition_cnt, void *rkt_opaque, void *msg_opaque))$partitioner);
			]"
		end

	c_rd_kafka_topic_conf_set_msg_order_cmp (topic_conf: POINTER; msg_order_cmp: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_topic_conf_set_msg_order_cmp ((rd_kafka_topic_conf_t*)$topic_conf, (int (*) (rd_kafka_message_t const *a, rd_kafka_message_t const *b))$msg_order_cmp);
			]"
		end

	c_rd_kafka_topic_partition_available (rkt: POINTER; partition: INTEGER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_topic_partition_available ((rd_kafka_topic_t const*)$rkt, (int32_t)$partition);
			]"
		end

	c_rd_kafka_msg_partitioner_random (rkt: POINTER; key: POINTER; keylen: NATURAL; partition_cnt: INTEGER; rkt_opaque: POINTER; msg_opaque: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_msg_partitioner_random ((rd_kafka_topic_t const*)$rkt, (void const*)$key, (size_t)$keylen, (int32_t)$partition_cnt, (void*)$rkt_opaque, (void*)$msg_opaque);
			]"
		end

	c_rd_kafka_msg_partitioner_consistent (rkt: POINTER; key: POINTER; keylen: NATURAL; partition_cnt: INTEGER; rkt_opaque: POINTER; msg_opaque: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_msg_partitioner_consistent ((rd_kafka_topic_t const*)$rkt, (void const*)$key, (size_t)$keylen, (int32_t)$partition_cnt, (void*)$rkt_opaque, (void*)$msg_opaque);
			]"
		end

	c_rd_kafka_msg_partitioner_consistent_random (rkt: POINTER; key: POINTER; keylen: NATURAL; partition_cnt: INTEGER; rkt_opaque: POINTER; msg_opaque: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_msg_partitioner_consistent_random ((rd_kafka_topic_t const*)$rkt, (void const*)$key, (size_t)$keylen, (int32_t)$partition_cnt, (void*)$rkt_opaque, (void*)$msg_opaque);
			]"
		end

	c_rd_kafka_msg_partitioner_murmur2 (rkt: POINTER; key: POINTER; keylen: NATURAL; partition_cnt: INTEGER; rkt_opaque: POINTER; msg_opaque: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_msg_partitioner_murmur2 ((rd_kafka_topic_t const*)$rkt, (void const*)$key, (size_t)$keylen, (int32_t)$partition_cnt, (void*)$rkt_opaque, (void*)$msg_opaque);
			]"
		end

	c_rd_kafka_msg_partitioner_murmur2_random (rkt: POINTER; key: POINTER; keylen: NATURAL; partition_cnt: INTEGER; rkt_opaque: POINTER; msg_opaque: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_msg_partitioner_murmur2_random ((rd_kafka_topic_t const*)$rkt, (void const*)$key, (size_t)$keylen, (int32_t)$partition_cnt, (void*)$rkt_opaque, (void*)$msg_opaque);
			]"
		end

	c_rd_kafka_msg_partitioner_fnv1a (rkt: POINTER; key: POINTER; keylen: NATURAL; partition_cnt: INTEGER; rkt_opaque: POINTER; msg_opaque: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_msg_partitioner_fnv1a ((rd_kafka_topic_t const*)$rkt, (void const*)$key, (size_t)$keylen, (int32_t)$partition_cnt, (void*)$rkt_opaque, (void*)$msg_opaque);
			]"
		end

	c_rd_kafka_msg_partitioner_fnv1a_random (rkt: POINTER; key: POINTER; keylen: NATURAL; partition_cnt: INTEGER; rkt_opaque: POINTER; msg_opaque: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_msg_partitioner_fnv1a_random ((rd_kafka_topic_t const*)$rkt, (void const*)$key, (size_t)$keylen, (int32_t)$partition_cnt, (void*)$rkt_opaque, (void*)$msg_opaque);
			]"
		end

	c_rd_kafka_new (type: INTEGER; conf: POINTER; errstr: POINTER; errstr_size: NATURAL): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_new ((rd_kafka_type_t)$type, (rd_kafka_conf_t*)$conf, (char*)$errstr, (size_t)$errstr_size);
			]"
		end

	c_rd_kafka_destroy (rk: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_destroy ((rd_kafka_t*)$rk);
			]"
		end

	c_rd_kafka_destroy_flags (rk: POINTER; flags: INTEGER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_destroy_flags ((rd_kafka_t*)$rk, (int)$flags);
			]"
		end

	c_rd_kafka_name (rk: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_name ((rd_kafka_t const*)$rk);
			]"
		end

	c_rd_kafka_type (rk: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_type ((rd_kafka_t const*)$rk);
			]"
		end

	c_rd_kafka_memberid (rk: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_memberid ((rd_kafka_t const*)$rk);
			]"
		end

	c_rd_kafka_clusterid (rk: POINTER; timeout_ms: INTEGER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_clusterid ((rd_kafka_t*)$rk, (int)$timeout_ms);
			]"
		end

	c_rd_kafka_controllerid (rk: POINTER; timeout_ms: INTEGER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_controllerid ((rd_kafka_t*)$rk, (int)$timeout_ms);
			]"
		end

	c_rd_kafka_topic_new (rk: POINTER; topic: POINTER; conf: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_topic_new ((rd_kafka_t*)$rk, (char const*)$topic, (rd_kafka_topic_conf_t*)$conf);
			]"
		end

	c_rd_kafka_topic_destroy (rkt: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_topic_destroy ((rd_kafka_topic_t*)$rkt);
			]"
		end

	c_rd_kafka_topic_name (rkt: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_topic_name ((rd_kafka_topic_t const*)$rkt);
			]"
		end

	c_rd_kafka_topic_opaque (rkt: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_topic_opaque ((rd_kafka_topic_t const*)$rkt);
			]"
		end

	c_rd_kafka_poll (rk: POINTER; timeout_ms: INTEGER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_poll ((rd_kafka_t*)$rk, (int)$timeout_ms);
			]"
		end

	c_rd_kafka_yield (rk: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_yield ((rd_kafka_t*)$rk);
			]"
		end

	c_rd_kafka_pause_partitions (rk: POINTER; partitions: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_pause_partitions ((rd_kafka_t*)$rk, (rd_kafka_topic_partition_list_t*)$partitions);
			]"
		end

	c_rd_kafka_resume_partitions (rk: POINTER; partitions: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_resume_partitions ((rd_kafka_t*)$rk, (rd_kafka_topic_partition_list_t*)$partitions);
			]"
		end

	c_rd_kafka_query_watermark_offsets (rk: POINTER; topic: POINTER; partition: INTEGER; low: POINTER; high: POINTER; timeout_ms: INTEGER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_query_watermark_offsets ((rd_kafka_t*)$rk, (char const*)$topic, (int32_t)$partition, (int64_t*)$low, (int64_t*)$high, (int)$timeout_ms);
			]"
		end

	c_rd_kafka_get_watermark_offsets (rk: POINTER; topic: POINTER; partition: INTEGER; low: POINTER; high: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_get_watermark_offsets ((rd_kafka_t*)$rk, (char const*)$topic, (int32_t)$partition, (int64_t*)$low, (int64_t*)$high);
			]"
		end

	c_rd_kafka_offsets_for_times (rk: POINTER; offsets: POINTER; timeout_ms: INTEGER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_offsets_for_times ((rd_kafka_t*)$rk, (rd_kafka_topic_partition_list_t*)$offsets, (int)$timeout_ms);
			]"
		end

	c_rd_kafka_mem_free (rk: POINTER; ptr: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_mem_free ((rd_kafka_t*)$rk, (void*)$ptr);
			]"
		end

	c_rd_kafka_queue_new (rk: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_queue_new ((rd_kafka_t*)$rk);
			]"
		end

	c_rd_kafka_queue_destroy (rkqu: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_queue_destroy ((rd_kafka_queue_t*)$rkqu);
			]"
		end

	c_rd_kafka_queue_get_main (rk: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_queue_get_main ((rd_kafka_t*)$rk);
			]"
		end

	c_rd_kafka_queue_get_consumer (rk: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_queue_get_consumer ((rd_kafka_t*)$rk);
			]"
		end

	c_rd_kafka_queue_get_partition (rk: POINTER; topic: POINTER; partition: INTEGER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_queue_get_partition ((rd_kafka_t*)$rk, (char const*)$topic, (int32_t)$partition);
			]"
		end

	c_rd_kafka_queue_get_background (rk: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_queue_get_background ((rd_kafka_t*)$rk);
			]"
		end

	c_rd_kafka_queue_forward (src: POINTER; dst: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_queue_forward ((rd_kafka_queue_t*)$src, (rd_kafka_queue_t*)$dst);
			]"
		end

	c_rd_kafka_set_log_queue (rk: POINTER; rkqu: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_set_log_queue ((rd_kafka_t*)$rk, (rd_kafka_queue_t*)$rkqu);
			]"
		end

	c_rd_kafka_queue_length (rkqu: POINTER): NATURAL
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_queue_length ((rd_kafka_queue_t*)$rkqu);
			]"
		end

	c_rd_kafka_queue_io_event_enable (rkqu: POINTER; fd: INTEGER; payload: POINTER; size: NATURAL)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_queue_io_event_enable ((rd_kafka_queue_t*)$rkqu, (int)$fd, (void const*)$payload, (size_t)$size);
			]"
		end

	c_rd_kafka_queue_cb_event_enable (rkqu: POINTER; event_cb: POINTER; qev_opaque: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_queue_cb_event_enable ((rd_kafka_queue_t*)$rkqu, (void (*) (rd_kafka_t *rk, void *qev_opaque))$event_cb, (void*)$qev_opaque);
			]"
		end

	c_rd_kafka_consume_start (rkt: POINTER; partition: INTEGER; offset: INTEGER_64): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_consume_start ((rd_kafka_topic_t*)$rkt, (int32_t)$partition, (int64_t)$offset);
			]"
		end

	c_rd_kafka_consume_start_queue (rkt: POINTER; partition: INTEGER; offset: INTEGER_64; rkqu: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_consume_start_queue ((rd_kafka_topic_t*)$rkt, (int32_t)$partition, (int64_t)$offset, (rd_kafka_queue_t*)$rkqu);
			]"
		end

	c_rd_kafka_consume_stop (rkt: POINTER; partition: INTEGER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_consume_stop ((rd_kafka_topic_t*)$rkt, (int32_t)$partition);
			]"
		end

	c_rd_kafka_seek (rkt: POINTER; partition: INTEGER; offset: INTEGER_64; timeout_ms: INTEGER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_seek ((rd_kafka_topic_t*)$rkt, (int32_t)$partition, (int64_t)$offset, (int)$timeout_ms);
			]"
		end

	c_rd_kafka_consume (rkt: POINTER; partition: INTEGER; timeout_ms: INTEGER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_consume ((rd_kafka_topic_t*)$rkt, (int32_t)$partition, (int)$timeout_ms);
			]"
		end

	c_rd_kafka_consume_batch (rkt: POINTER; partition: INTEGER; timeout_ms: INTEGER; rkmessages: POINTER; rkmessages_size: NATURAL): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_consume_batch ((rd_kafka_topic_t*)$rkt, (int32_t)$partition, (int)$timeout_ms, (rd_kafka_message_t**)$rkmessages, (size_t)$rkmessages_size);
			]"
		end

	c_rd_kafka_consume_callback (rkt: POINTER; partition: INTEGER; timeout_ms: INTEGER; consume_cb: POINTER; commit_opaque: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_consume_callback ((rd_kafka_topic_t*)$rkt, (int32_t)$partition, (int)$timeout_ms, (void (*) (rd_kafka_message_t *rkmessage, void *commit_opaque))$consume_cb, (void*)$commit_opaque);
			]"
		end

	c_rd_kafka_consume_queue (rkqu: POINTER; timeout_ms: INTEGER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_consume_queue ((rd_kafka_queue_t*)$rkqu, (int)$timeout_ms);
			]"
		end

	c_rd_kafka_consume_batch_queue (rkqu: POINTER; timeout_ms: INTEGER; rkmessages: POINTER; rkmessages_size: NATURAL): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_consume_batch_queue ((rd_kafka_queue_t*)$rkqu, (int)$timeout_ms, (rd_kafka_message_t**)$rkmessages, (size_t)$rkmessages_size);
			]"
		end

	c_rd_kafka_consume_callback_queue (rkqu: POINTER; timeout_ms: INTEGER; consume_cb: POINTER; commit_opaque: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_consume_callback_queue ((rd_kafka_queue_t*)$rkqu, (int)$timeout_ms, (void (*) (rd_kafka_message_t *rkmessage, void *commit_opaque))$consume_cb, (void*)$commit_opaque);
			]"
		end

	c_rd_kafka_offset_store (rkt: POINTER; partition: INTEGER; offset: INTEGER_64): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_offset_store ((rd_kafka_topic_t*)$rkt, (int32_t)$partition, (int64_t)$offset);
			]"
		end

	c_rd_kafka_offsets_store (rk: POINTER; offsets: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_offsets_store ((rd_kafka_t*)$rk, (rd_kafka_topic_partition_list_t*)$offsets);
			]"
		end

	c_rd_kafka_subscribe (rk: POINTER; topics: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_subscribe ((rd_kafka_t*)$rk, (rd_kafka_topic_partition_list_t const*)$topics);
			]"
		end

	c_rd_kafka_unsubscribe (rk: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_unsubscribe ((rd_kafka_t*)$rk);
			]"
		end

	c_rd_kafka_subscription (rk: POINTER; topics: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_subscription ((rd_kafka_t*)$rk, (rd_kafka_topic_partition_list_t**)$topics);
			]"
		end

	c_rd_kafka_consumer_poll (rk: POINTER; timeout_ms: INTEGER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_consumer_poll ((rd_kafka_t*)$rk, (int)$timeout_ms);
			]"
		end

	c_rd_kafka_consumer_close (rk: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_consumer_close ((rd_kafka_t*)$rk);
			]"
		end

	c_rd_kafka_assign (rk: POINTER; partitions: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_assign ((rd_kafka_t*)$rk, (rd_kafka_topic_partition_list_t const*)$partitions);
			]"
		end

	c_rd_kafka_assignment (rk: POINTER; partitions: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_assignment ((rd_kafka_t*)$rk, (rd_kafka_topic_partition_list_t**)$partitions);
			]"
		end

	c_rd_kafka_commit (rk: POINTER; offsets: POINTER; async: INTEGER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_commit ((rd_kafka_t*)$rk, (rd_kafka_topic_partition_list_t const*)$offsets, (int)$async);
			]"
		end

	c_rd_kafka_commit_message (rk: POINTER; rkmessage: POINTER; async: INTEGER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_commit_message ((rd_kafka_t*)$rk, (rd_kafka_message_t const*)$rkmessage, (int)$async);
			]"
		end

	c_rd_kafka_commit_queue (rk: POINTER; offsets: POINTER; rkqu: POINTER; cb: POINTER; commit_opaque: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_commit_queue ((rd_kafka_t*)$rk, (rd_kafka_topic_partition_list_t const*)$offsets, (rd_kafka_queue_t*)$rkqu, (void (*) (rd_kafka_t *rk, rd_kafka_resp_err_t err, rd_kafka_topic_partition_list_t *offsets, void *commit_opaque))$cb, (void*)$commit_opaque);
			]"
		end

	c_rd_kafka_committed (rk: POINTER; partitions: POINTER; timeout_ms: INTEGER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_committed ((rd_kafka_t*)$rk, (rd_kafka_topic_partition_list_t*)$partitions, (int)$timeout_ms);
			]"
		end

	c_rd_kafka_position (rk: POINTER; partitions: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_position ((rd_kafka_t*)$rk, (rd_kafka_topic_partition_list_t*)$partitions);
			]"
		end

	c_rd_kafka_consumer_group_metadata (rk: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_consumer_group_metadata ((rd_kafka_t*)$rk);
			]"
		end

	c_rd_kafka_consumer_group_metadata_destroy (anonymous_1: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_consumer_group_metadata_destroy ((rd_kafka_consumer_group_metadata_t*)$anonymous_1);
			]"
		end

	c_rd_kafka_consumer_group_metadata_write (cgmd: POINTER; bufferp: POINTER; sizep: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_consumer_group_metadata_write ((rd_kafka_consumer_group_metadata_t const*)$cgmd, (void**)$bufferp, (size_t*)$sizep);
			]"
		end

	c_rd_kafka_consumer_group_metadata_read (cgmdp: POINTER; buffer: POINTER; size: NATURAL): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_consumer_group_metadata_read ((rd_kafka_consumer_group_metadata_t**)$cgmdp, (void const*)$buffer, (size_t)$size);
			]"
		end

	c_rd_kafka_produce (rkt: POINTER; partition: INTEGER; msgflags: INTEGER; payload: POINTER; len: NATURAL; key: POINTER; keylen: NATURAL; msg_opaque: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_produce ((rd_kafka_topic_t*)$rkt, (int32_t)$partition, (int)$msgflags, (void*)$payload, (size_t)$len, (void const*)$key, (size_t)$keylen, (void*)$msg_opaque);
			]"
		end

	c_rd_kafka_producev (rk: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_producev ((rd_kafka_t*)$rk);
			]"
		end

	c_rd_kafka_produceva (rk: POINTER; vus: POINTER; cnt: NATURAL): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_produceva ((rd_kafka_t*)$rk, (rd_kafka_vu_t const*)$vus, (size_t)$cnt);
			]"
		end

	c_rd_kafka_produce_batch (rkt: POINTER; partition: INTEGER; msgflags: INTEGER; rkmessages: POINTER; message_cnt: INTEGER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_produce_batch ((rd_kafka_topic_t*)$rkt, (int32_t)$partition, (int)$msgflags, (rd_kafka_message_t*)$rkmessages, (int)$message_cnt);
			]"
		end

	c_rd_kafka_flush (rk: POINTER; timeout_ms: INTEGER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_flush ((rd_kafka_t*)$rk, (int)$timeout_ms);
			]"
		end

	c_rd_kafka_purge (rk: POINTER; purge_flags: INTEGER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_purge ((rd_kafka_t*)$rk, (int)$purge_flags);
			]"
		end

	c_rd_kafka_metadata (rk: POINTER; all_topics: INTEGER; only_rkt: POINTER; metadatap: POINTER; timeout_ms: INTEGER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_metadata ((rd_kafka_t*)$rk, (int)$all_topics, (rd_kafka_topic_t*)$only_rkt, (struct rd_kafka_metadata const**)$metadatap, (int)$timeout_ms);
			]"
		end

	c_rd_kafka_metadata_destroy (metadata: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_metadata_destroy ((struct rd_kafka_metadata const*)$metadata);
			]"
		end

	c_rd_kafka_list_groups (rk: POINTER; group: POINTER; grplistp: POINTER; timeout_ms: INTEGER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_list_groups ((rd_kafka_t*)$rk, (char const*)$group, (struct rd_kafka_group_list const**)$grplistp, (int)$timeout_ms);
			]"
		end

	c_rd_kafka_group_list_destroy (grplist: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_group_list_destroy ((struct rd_kafka_group_list const*)$grplist);
			]"
		end

	c_rd_kafka_brokers_add (rk: POINTER; brokerlist: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_brokers_add ((rd_kafka_t*)$rk, (char const*)$brokerlist);
			]"
		end

	c_rd_kafka_set_logger (rk: POINTER; func: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_set_logger ((rd_kafka_t*)$rk, (void (*) (rd_kafka_t const *rk, int level, char const *fac, char const *buf))$func);
			]"
		end

	c_rd_kafka_set_log_level (rk: POINTER; level: INTEGER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_set_log_level ((rd_kafka_t*)$rk, (int)$level);
			]"
		end

	c_rd_kafka_log_print (rk: POINTER; level: INTEGER; fac: POINTER; buf: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_log_print ((rd_kafka_t const*)$rk, (int)$level, (char const*)$fac, (char const*)$buf);
			]"
		end

	c_rd_kafka_log_syslog (rk: POINTER; level: INTEGER; fac: POINTER; buf: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_log_syslog ((rd_kafka_t const*)$rk, (int)$level, (char const*)$fac, (char const*)$buf);
			]"
		end

	c_rd_kafka_outq_len (rk: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_outq_len ((rd_kafka_t*)$rk);
			]"
		end

	c_rd_kafka_dump (fp: POINTER; rk: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_dump ((FILE*)$fp, (rd_kafka_t*)$rk);
			]"
		end

	c_rd_kafka_poll_set_consumer (rk: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_poll_set_consumer ((rd_kafka_t*)$rk);
			]"
		end

	c_rd_kafka_event_type (rkev: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_event_type ((rd_kafka_event_t const*)$rkev);
			]"
		end

	c_rd_kafka_event_name (rkev: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_event_name ((rd_kafka_event_t const*)$rkev);
			]"
		end

	c_rd_kafka_event_destroy (rkev: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_event_destroy ((rd_kafka_event_t*)$rkev);
			]"
		end

	c_rd_kafka_event_message_next (rkev: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_event_message_next ((rd_kafka_event_t*)$rkev);
			]"
		end

	c_rd_kafka_event_message_array (rkev: POINTER; rkmessages: POINTER; size: NATURAL): NATURAL
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_event_message_array ((rd_kafka_event_t*)$rkev, (rd_kafka_message_t const**)$rkmessages, (size_t)$size);
			]"
		end

	c_rd_kafka_event_message_count (rkev: POINTER): NATURAL
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_event_message_count ((rd_kafka_event_t*)$rkev);
			]"
		end

	c_rd_kafka_event_config_string (rkev: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_event_config_string ((rd_kafka_event_t*)$rkev);
			]"
		end

	c_rd_kafka_event_error (rkev: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_event_error ((rd_kafka_event_t*)$rkev);
			]"
		end

	c_rd_kafka_event_error_string (rkev: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_event_error_string ((rd_kafka_event_t*)$rkev);
			]"
		end

	c_rd_kafka_event_error_is_fatal (rkev: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_event_error_is_fatal ((rd_kafka_event_t*)$rkev);
			]"
		end

	c_rd_kafka_event_opaque (rkev: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_event_opaque ((rd_kafka_event_t*)$rkev);
			]"
		end

	c_rd_kafka_event_log (rkev: POINTER; fac: POINTER; str: POINTER; level: TYPED_POINTER [INTEGER]): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_event_log ((rd_kafka_event_t*)$rkev, (char const**)$fac, (char const**)$str, (int*)$level);
			]"
		end

	c_rd_kafka_event_debug_contexts (rkev: POINTER; dst: POINTER; dstsize: NATURAL): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_event_debug_contexts ((rd_kafka_event_t*)$rkev, (char*)$dst, (size_t)$dstsize);
			]"
		end

	c_rd_kafka_event_stats (rkev: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_event_stats ((rd_kafka_event_t*)$rkev);
			]"
		end

	c_rd_kafka_event_topic_partition_list (rkev: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_event_topic_partition_list ((rd_kafka_event_t*)$rkev);
			]"
		end

	c_rd_kafka_event_topic_partition (rkev: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_event_topic_partition ((rd_kafka_event_t*)$rkev);
			]"
		end

	c_rd_kafka_event_create_topics_result (rkev: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_event_CreateTopics_result ((rd_kafka_event_t*)$rkev);
			]"
		end

	c_rd_kafka_event_delete_topics_result (rkev: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_event_DeleteTopics_result ((rd_kafka_event_t*)$rkev);
			]"
		end

	c_rd_kafka_event_create_partitions_result (rkev: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_event_CreatePartitions_result ((rd_kafka_event_t*)$rkev);
			]"
		end

	c_rd_kafka_event_alter_configs_result (rkev: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_event_AlterConfigs_result ((rd_kafka_event_t*)$rkev);
			]"
		end

	c_rd_kafka_event_describe_configs_result (rkev: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_event_DescribeConfigs_result ((rd_kafka_event_t*)$rkev);
			]"
		end

	c_rd_kafka_queue_poll (rkqu: POINTER; timeout_ms: INTEGER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_queue_poll ((rd_kafka_queue_t*)$rkqu, (int)$timeout_ms);
			]"
		end

	c_rd_kafka_queue_poll_callback (rkqu: POINTER; timeout_ms: INTEGER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_queue_poll_callback ((rd_kafka_queue_t*)$rkqu, (int)$timeout_ms);
			]"
		end

	c_rd_kafka_conf_interceptor_add_on_conf_set (conf: POINTER; ic_name: POINTER; on_conf_set: POINTER; ic_opaque: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_conf_interceptor_add_on_conf_set ((rd_kafka_conf_t*)$conf, (char const*)$ic_name, (rd_kafka_interceptor_f_on_conf_set_t*)$on_conf_set, (void*)$ic_opaque);
			]"
		end

	c_rd_kafka_conf_interceptor_add_on_conf_dup (conf: POINTER; ic_name: POINTER; on_conf_dup: POINTER; ic_opaque: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_conf_interceptor_add_on_conf_dup ((rd_kafka_conf_t*)$conf, (char const*)$ic_name, (rd_kafka_interceptor_f_on_conf_dup_t*)$on_conf_dup, (void*)$ic_opaque);
			]"
		end

	c_rd_kafka_conf_interceptor_add_on_conf_destroy (conf: POINTER; ic_name: POINTER; on_conf_destroy: POINTER; ic_opaque: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_conf_interceptor_add_on_conf_destroy ((rd_kafka_conf_t*)$conf, (char const*)$ic_name, (rd_kafka_interceptor_f_on_conf_destroy_t*)$on_conf_destroy, (void*)$ic_opaque);
			]"
		end

	c_rd_kafka_conf_interceptor_add_on_new (conf: POINTER; ic_name: POINTER; on_new: POINTER; ic_opaque: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_conf_interceptor_add_on_new ((rd_kafka_conf_t*)$conf, (char const*)$ic_name, (rd_kafka_interceptor_f_on_new_t*)$on_new, (void*)$ic_opaque);
			]"
		end

	c_rd_kafka_interceptor_add_on_destroy (rk: POINTER; ic_name: POINTER; on_destroy: POINTER; ic_opaque: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_interceptor_add_on_destroy ((rd_kafka_t*)$rk, (char const*)$ic_name, (rd_kafka_interceptor_f_on_destroy_t*)$on_destroy, (void*)$ic_opaque);
			]"
		end

	c_rd_kafka_interceptor_add_on_send (rk: POINTER; ic_name: POINTER; on_send: POINTER; ic_opaque: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_interceptor_add_on_send ((rd_kafka_t*)$rk, (char const*)$ic_name, (rd_kafka_interceptor_f_on_send_t*)$on_send, (void*)$ic_opaque);
			]"
		end

	c_rd_kafka_interceptor_add_on_acknowledgement (rk: POINTER; ic_name: POINTER; on_acknowledgement: POINTER; ic_opaque: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_interceptor_add_on_acknowledgement ((rd_kafka_t*)$rk, (char const*)$ic_name, (rd_kafka_interceptor_f_on_acknowledgement_t*)$on_acknowledgement, (void*)$ic_opaque);
			]"
		end

	c_rd_kafka_interceptor_add_on_consume (rk: POINTER; ic_name: POINTER; on_consume: POINTER; ic_opaque: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_interceptor_add_on_consume ((rd_kafka_t*)$rk, (char const*)$ic_name, (rd_kafka_interceptor_f_on_consume_t*)$on_consume, (void*)$ic_opaque);
			]"
		end

	c_rd_kafka_interceptor_add_on_commit (rk: POINTER; ic_name: POINTER; on_commit: POINTER; ic_opaque: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_interceptor_add_on_commit ((rd_kafka_t*)$rk, (char const*)$ic_name, (rd_kafka_interceptor_f_on_commit_t*)$on_commit, (void*)$ic_opaque);
			]"
		end

	c_rd_kafka_interceptor_add_on_request_sent (rk: POINTER; ic_name: POINTER; on_request_sent: POINTER; ic_opaque: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_interceptor_add_on_request_sent ((rd_kafka_t*)$rk, (char const*)$ic_name, (rd_kafka_interceptor_f_on_request_sent_t*)$on_request_sent, (void*)$ic_opaque);
			]"
		end

	c_rd_kafka_interceptor_add_on_thread_start (rk: POINTER; ic_name: POINTER; on_thread_start: POINTER; ic_opaque: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_interceptor_add_on_thread_start ((rd_kafka_t*)$rk, (char const*)$ic_name, (rd_kafka_interceptor_f_on_thread_start_t*)$on_thread_start, (void*)$ic_opaque);
			]"
		end

	c_rd_kafka_interceptor_add_on_thread_exit (rk: POINTER; ic_name: POINTER; on_thread_exit: POINTER; ic_opaque: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_interceptor_add_on_thread_exit ((rd_kafka_t*)$rk, (char const*)$ic_name, (rd_kafka_interceptor_f_on_thread_exit_t*)$on_thread_exit, (void*)$ic_opaque);
			]"
		end

	c_rd_kafka_topic_result_error (topicres: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_topic_result_error ((rd_kafka_topic_result_t const*)$topicres);
			]"
		end

	c_rd_kafka_topic_result_error_string (topicres: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_topic_result_error_string ((rd_kafka_topic_result_t const*)$topicres);
			]"
		end

	c_rd_kafka_topic_result_name (topicres: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_topic_result_name ((rd_kafka_topic_result_t const*)$topicres);
			]"
		end

	c_rd_kafka_admin_options_new (rk: POINTER; for_api: INTEGER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_AdminOptions_new ((rd_kafka_t*)$rk, (rd_kafka_admin_op_t)$for_api);
			]"
		end

	c_rd_kafka_admin_options_destroy (options: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_AdminOptions_destroy ((rd_kafka_AdminOptions_t*)$options);
			]"
		end

	c_rd_kafka_admin_options_set_request_timeout (options: POINTER; timeout_ms: INTEGER; errstr: POINTER; errstr_size: NATURAL): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_AdminOptions_set_request_timeout ((rd_kafka_AdminOptions_t*)$options, (int)$timeout_ms, (char*)$errstr, (size_t)$errstr_size);
			]"
		end

	c_rd_kafka_admin_options_set_operation_timeout (options: POINTER; timeout_ms: INTEGER; errstr: POINTER; errstr_size: NATURAL): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_AdminOptions_set_operation_timeout ((rd_kafka_AdminOptions_t*)$options, (int)$timeout_ms, (char*)$errstr, (size_t)$errstr_size);
			]"
		end

	c_rd_kafka_admin_options_set_validate_only (options: POINTER; true_or_false: INTEGER; errstr: POINTER; errstr_size: NATURAL): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_AdminOptions_set_validate_only ((rd_kafka_AdminOptions_t*)$options, (int)$true_or_false, (char*)$errstr, (size_t)$errstr_size);
			]"
		end

	c_rd_kafka_admin_options_set_broker (options: POINTER; broker_id: INTEGER; errstr: POINTER; errstr_size: NATURAL): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_AdminOptions_set_broker ((rd_kafka_AdminOptions_t*)$options, (int32_t)$broker_id, (char*)$errstr, (size_t)$errstr_size);
			]"
		end

	c_rd_kafka_admin_options_set_opaque (options: POINTER; ev_opaque: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_AdminOptions_set_opaque ((rd_kafka_AdminOptions_t*)$options, (void*)$ev_opaque);
			]"
		end

	c_rd_kafka_new_topic_destroy (new_topic: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_NewTopic_destroy ((rd_kafka_NewTopic_t*)$new_topic);
			]"
		end

	c_rd_kafka_new_topic_destroy_array (new_topics: POINTER; new_topic_cnt: NATURAL)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_NewTopic_destroy_array ((rd_kafka_NewTopic_t**)$new_topics, (size_t)$new_topic_cnt);
			]"
		end

	c_rd_kafka_new_topic_set_replica_assignment (new_topic: POINTER; partition: INTEGER; broker_ids: POINTER; broker_id_cnt: NATURAL; errstr: POINTER; errstr_size: NATURAL): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_NewTopic_set_replica_assignment ((rd_kafka_NewTopic_t*)$new_topic, (int32_t)$partition, (int32_t*)$broker_ids, (size_t)$broker_id_cnt, (char*)$errstr, (size_t)$errstr_size);
			]"
		end

	c_rd_kafka_new_topic_set_config (new_topic: POINTER; name: POINTER; value: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_NewTopic_set_config ((rd_kafka_NewTopic_t*)$new_topic, (char const*)$name, (char const*)$value);
			]"
		end

	c_rd_kafka_create_topics (rk: POINTER; new_topics: POINTER; new_topic_cnt: NATURAL; options: POINTER; rkqu: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_CreateTopics ((rd_kafka_t*)$rk, (rd_kafka_NewTopic_t**)$new_topics, (size_t)$new_topic_cnt, (rd_kafka_AdminOptions_t const*)$options, (rd_kafka_queue_t*)$rkqu);
			]"
		end

	c_rd_kafka_create_topics_result_topics (a_result: POINTER; cntp: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_CreateTopics_result_topics ((rd_kafka_CreateTopics_result_t const*)$a_result, (size_t*)$cntp);
			]"
		end

	c_rd_kafka_delete_topic_destroy (del_topic: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_DeleteTopic_destroy ((rd_kafka_DeleteTopic_t*)$del_topic);
			]"
		end

	c_rd_kafka_delete_topic_destroy_array (del_topics: POINTER; del_topic_cnt: NATURAL)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_DeleteTopic_destroy_array ((rd_kafka_DeleteTopic_t**)$del_topics, (size_t)$del_topic_cnt);
			]"
		end

	c_rd_kafka_delete_topics (rk: POINTER; del_topics: POINTER; del_topic_cnt: NATURAL; options: POINTER; rkqu: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_DeleteTopics ((rd_kafka_t*)$rk, (rd_kafka_DeleteTopic_t**)$del_topics, (size_t)$del_topic_cnt, (rd_kafka_AdminOptions_t const*)$options, (rd_kafka_queue_t*)$rkqu);
			]"
		end

	c_rd_kafka_delete_topics_result_topics (a_result: POINTER; cntp: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_DeleteTopics_result_topics ((rd_kafka_DeleteTopics_result_t const*)$a_result, (size_t*)$cntp);
			]"
		end

	c_rd_kafka_new_partitions_destroy (new_parts: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_NewPartitions_destroy ((rd_kafka_NewPartitions_t*)$new_parts);
			]"
		end

	c_rd_kafka_new_partitions_destroy_array (new_parts: POINTER; new_parts_cnt: NATURAL)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_NewPartitions_destroy_array ((rd_kafka_NewPartitions_t**)$new_parts, (size_t)$new_parts_cnt);
			]"
		end

	c_rd_kafka_new_partitions_set_replica_assignment (new_parts: POINTER; new_partition_idx: INTEGER; broker_ids: POINTER; broker_id_cnt: NATURAL; errstr: POINTER; errstr_size: NATURAL): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_NewPartitions_set_replica_assignment ((rd_kafka_NewPartitions_t*)$new_parts, (int32_t)$new_partition_idx, (int32_t*)$broker_ids, (size_t)$broker_id_cnt, (char*)$errstr, (size_t)$errstr_size);
			]"
		end

	c_rd_kafka_create_partitions (rk: POINTER; new_parts: POINTER; new_parts_cnt: NATURAL; options: POINTER; rkqu: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_CreatePartitions ((rd_kafka_t*)$rk, (rd_kafka_NewPartitions_t**)$new_parts, (size_t)$new_parts_cnt, (rd_kafka_AdminOptions_t const*)$options, (rd_kafka_queue_t*)$rkqu);
			]"
		end

	c_rd_kafka_create_partitions_result_topics (a_result: POINTER; cntp: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_CreatePartitions_result_topics ((rd_kafka_CreatePartitions_result_t const*)$a_result, (size_t*)$cntp);
			]"
		end

	c_rd_kafka_config_source_name (confsource: INTEGER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_ConfigSource_name ((rd_kafka_ConfigSource_t)$confsource);
			]"
		end

	c_rd_kafka_config_entry_name (entry: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_ConfigEntry_name ((rd_kafka_ConfigEntry_t const*)$entry);
			]"
		end

	c_rd_kafka_config_entry_value (entry: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_ConfigEntry_value ((rd_kafka_ConfigEntry_t const*)$entry);
			]"
		end

	c_rd_kafka_config_entry_source (entry: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_ConfigEntry_source ((rd_kafka_ConfigEntry_t const*)$entry);
			]"
		end

	c_rd_kafka_config_entry_is_read_only (entry: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_ConfigEntry_is_read_only ((rd_kafka_ConfigEntry_t const*)$entry);
			]"
		end

	c_rd_kafka_config_entry_is_default (entry: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_ConfigEntry_is_default ((rd_kafka_ConfigEntry_t const*)$entry);
			]"
		end

	c_rd_kafka_config_entry_is_sensitive (entry: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_ConfigEntry_is_sensitive ((rd_kafka_ConfigEntry_t const*)$entry);
			]"
		end

	c_rd_kafka_config_entry_is_synonym (entry: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_ConfigEntry_is_synonym ((rd_kafka_ConfigEntry_t const*)$entry);
			]"
		end

	c_rd_kafka_config_entry_synonyms (entry: POINTER; cntp: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_ConfigEntry_synonyms ((rd_kafka_ConfigEntry_t const*)$entry, (size_t*)$cntp);
			]"
		end

	c_rd_kafka_resource_type_name (restype: INTEGER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_ResourceType_name ((rd_kafka_ResourceType_t)$restype);
			]"
		end

	c_rd_kafka_config_resource_new (restype: INTEGER; resname: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_ConfigResource_new ((rd_kafka_ResourceType_t)$restype, (char const*)$resname);
			]"
		end

	c_rd_kafka_config_resource_destroy (config: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_ConfigResource_destroy ((rd_kafka_ConfigResource_t*)$config);
			]"
		end

	c_rd_kafka_config_resource_destroy_array (config: POINTER; config_cnt: NATURAL)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_ConfigResource_destroy_array ((rd_kafka_ConfigResource_t**)$config, (size_t)$config_cnt);
			]"
		end

	c_rd_kafka_config_resource_set_config (config: POINTER; name: POINTER; value: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_ConfigResource_set_config ((rd_kafka_ConfigResource_t*)$config, (char const*)$name, (char const*)$value);
			]"
		end

	c_rd_kafka_config_resource_configs (config: POINTER; cntp: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_ConfigResource_configs ((rd_kafka_ConfigResource_t const*)$config, (size_t*)$cntp);
			]"
		end

	c_rd_kafka_config_resource_type (config: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_ConfigResource_type ((rd_kafka_ConfigResource_t const*)$config);
			]"
		end

	c_rd_kafka_config_resource_name (config: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_ConfigResource_name ((rd_kafka_ConfigResource_t const*)$config);
			]"
		end

	c_rd_kafka_config_resource_error (config: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_ConfigResource_error ((rd_kafka_ConfigResource_t const*)$config);
			]"
		end

	c_rd_kafka_config_resource_error_string (config: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_ConfigResource_error_string ((rd_kafka_ConfigResource_t const*)$config);
			]"
		end

	c_rd_kafka_alter_configs (rk: POINTER; configs: POINTER; config_cnt: NATURAL; options: POINTER; rkqu: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_AlterConfigs ((rd_kafka_t*)$rk, (rd_kafka_ConfigResource_t**)$configs, (size_t)$config_cnt, (rd_kafka_AdminOptions_t const*)$options, (rd_kafka_queue_t*)$rkqu);
			]"
		end

	c_rd_kafka_alter_configs_result_resources (a_result: POINTER; cntp: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_AlterConfigs_result_resources ((rd_kafka_AlterConfigs_result_t const*)$a_result, (size_t*)$cntp);
			]"
		end

	c_rd_kafka_describe_configs (rk: POINTER; configs: POINTER; config_cnt: NATURAL; options: POINTER; rkqu: POINTER)
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				rd_kafka_DescribeConfigs ((rd_kafka_t*)$rk, (rd_kafka_ConfigResource_t**)$configs, (size_t)$config_cnt, (rd_kafka_AdminOptions_t const*)$options, (rd_kafka_queue_t*)$rkqu);
			]"
		end

	c_rd_kafka_describe_configs_result_resources (a_result: POINTER; cntp: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_DescribeConfigs_result_resources ((rd_kafka_DescribeConfigs_result_t const*)$a_result, (size_t*)$cntp);
			]"
		end

	c_rd_kafka_oauthbearer_set_token (rk: POINTER; token_value: POINTER; md_lifetime_ms: INTEGER_64; md_principal_name: POINTER; extensions: POINTER; extension_size: NATURAL; errstr: POINTER; errstr_size: NATURAL): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_oauthbearer_set_token ((rd_kafka_t*)$rk, (char const*)$token_value, (int64_t)$md_lifetime_ms, (char const*)$md_principal_name, (char const**)$extensions, (size_t)$extension_size, (char*)$errstr, (size_t)$errstr_size);
			]"
		end

	c_rd_kafka_oauthbearer_set_token_failure (rk: POINTER; errstr: POINTER): INTEGER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_oauthbearer_set_token_failure ((rd_kafka_t*)$rk, (char const*)$errstr);
			]"
		end

	c_rd_kafka_init_transactions (rk: POINTER; timeout_ms: INTEGER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_init_transactions ((rd_kafka_t*)$rk, (int)$timeout_ms);
			]"
		end

	c_rd_kafka_begin_transaction (rk: POINTER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_begin_transaction ((rd_kafka_t*)$rk);
			]"
		end

	c_rd_kafka_send_offsets_to_transaction (rk: POINTER; offsets: POINTER; cgmetadata: POINTER; timeout_ms: INTEGER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_send_offsets_to_transaction ((rd_kafka_t*)$rk, (rd_kafka_topic_partition_list_t const*)$offsets, (rd_kafka_consumer_group_metadata_t const*)$cgmetadata, (int)$timeout_ms);
			]"
		end

	c_rd_kafka_commit_transaction (rk: POINTER; timeout_ms: INTEGER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_commit_transaction ((rd_kafka_t*)$rk, (int)$timeout_ms);
			]"
		end

	c_rd_kafka_abort_transaction (rk: POINTER; timeout_ms: INTEGER): POINTER
		external
			"C inline use <rdkafka.h>"
		alias
			"[
				return rd_kafka_abort_transaction ((rd_kafka_t*)$rk, (int)$timeout_ms);
			]"
		end

feature -- Externals Address

end
